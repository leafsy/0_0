/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, e = Symbol(), i = new WeakMap; class s { constructor(t, i, s) { if (this._$cssResult$ = !0, s !== e) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead."); this.cssText = t, this.t = i } get styleSheet() { let e = this.o; const s = this.t; if (t && void 0 === e) { const t = void 0 !== s && 1 === s.length; t && (e = i.get(s)), void 0 === e && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText), t && i.set(s, e)) } return e } toString() { return this.cssText } } const r = (t, ...i) => { const r = 1 === t.length ? t[0] : i.reduce(((e, i, s) => e + (t => { if (!0 === t._$cssResult$) return t.cssText; if ("number" == typeof t) return t; throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.") })(i) + t[s + 1]), t[0]); return new s(r, t, e) }, o = t ? t => t : t => t instanceof CSSStyleSheet ? (t => { let i = ""; for (const e of t.cssRules) i += e.cssText; return (t => new s("string" == typeof t ? t : t + "", void 0, e))(i) })(t) : t
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */; var n; const a = window.trustedTypes, l = a ? a.emptyScript : "", c = window.reactiveElementPolyfillSupport, h = { toAttribute(t, e) { switch (e) { case Boolean: t = t ? l : null; break; case Object: case Array: t = null == t ? t : JSON.stringify(t) }return t }, fromAttribute(t, e) { let i = t; switch (e) { case Boolean: i = null !== t; break; case Number: i = null === t ? null : Number(t); break; case Object: case Array: try { i = JSON.parse(t) } catch (t) { i = null } }return i } }, p = (t, e) => e !== t && (e == e || t == t), u = { attribute: !0, type: String, converter: h, reflect: !1, hasChanged: p }; class d extends HTMLElement { constructor() { super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u() } static addInitializer(t) { var e; null !== (e = this.h) && void 0 !== e || (this.h = []), this.h.push(t) } static get observedAttributes() { this.finalize(); const t = []; return this.elementProperties.forEach(((e, i) => { const s = this._$Ep(i, e); void 0 !== s && (this._$Ev.set(s, i), t.push(s)) })), t } static createProperty(t, e = u) { if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) { const i = "symbol" == typeof t ? Symbol() : "__" + t, s = this.getPropertyDescriptor(t, i, e); void 0 !== s && Object.defineProperty(this.prototype, t, s) } } static getPropertyDescriptor(t, e, i) { return { get() { return this[e] }, set(s) { const r = this[t]; this[e] = s, this.requestUpdate(t, r, i) }, configurable: !0, enumerable: !0 } } static getPropertyOptions(t) { return this.elementProperties.get(t) || u } static finalize() { if (this.hasOwnProperty("finalized")) return !1; this.finalized = !0; const t = Object.getPrototypeOf(this); if (t.finalize(), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) { const t = this.properties, e = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)]; for (const i of e) this.createProperty(i, t[i]) } return this.elementStyles = this.finalizeStyles(this.styles), !0 } static finalizeStyles(t) { const e = []; if (Array.isArray(t)) { const i = new Set(t.flat(1 / 0).reverse()); for (const t of i) e.unshift(o(t)) } else void 0 !== t && e.push(o(t)); return e } static _$Ep(t, e) { const i = e.attribute; return !1 === i ? void 0 : "string" == typeof i ? i : "string" == typeof t ? t.toLowerCase() : void 0 } u() { var t; this._$E_ = new Promise((t => this.enableUpdating = t)), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach((t => t(this))) } addController(t) { var e, i; (null !== (e = this._$ES) && void 0 !== e ? e : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (i = t.hostConnected) || void 0 === i || i.call(t)) } removeController(t) { var e; null === (e = this._$ES) || void 0 === e || e.splice(this._$ES.indexOf(t) >>> 0, 1) } _$Eg() { this.constructor.elementProperties.forEach(((t, e) => { this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]) })) } createRenderRoot() { var e; const i = null !== (e = this.shadowRoot) && void 0 !== e ? e : this.attachShadow(this.constructor.shadowRootOptions); return ((e, i) => { t ? e.adoptedStyleSheets = i.map((t => t instanceof CSSStyleSheet ? t : t.styleSheet)) : i.forEach((t => { const i = document.createElement("style"), s = window.litNonce; void 0 !== s && i.setAttribute("nonce", s), i.textContent = t.cssText, e.appendChild(i) })) })(i, this.constructor.elementStyles), i } connectedCallback() { var t; void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach((t => { var e; return null === (e = t.hostConnected) || void 0 === e ? void 0 : e.call(t) })) } enableUpdating(t) { } disconnectedCallback() { var t; null === (t = this._$ES) || void 0 === t || t.forEach((t => { var e; return null === (e = t.hostDisconnected) || void 0 === e ? void 0 : e.call(t) })) } attributeChangedCallback(t, e, i) { this._$AK(t, i) } _$EO(t, e, i = u) { var s, r; const o = this.constructor._$Ep(t, i); if (void 0 !== o && !0 === i.reflect) { const n = (null !== (r = null === (s = i.converter) || void 0 === s ? void 0 : s.toAttribute) && void 0 !== r ? r : h.toAttribute)(e, i.type); this._$El = t, null == n ? this.removeAttribute(o) : this.setAttribute(o, n), this._$El = null } } _$AK(t, e) { var i, s; const r = this.constructor, o = r._$Ev.get(t); if (void 0 !== o && this._$El !== o) { const t = r.getPropertyOptions(o), n = t.converter, a = null !== (s = null !== (i = null == n ? void 0 : n.fromAttribute) && void 0 !== i ? i : "function" == typeof n ? n : null) && void 0 !== s ? s : h.fromAttribute; this._$El = o, this[o] = a(e, t.type), this._$El = null } } requestUpdate(t, e, i) { let s = !0; void 0 !== t && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || p)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), !0 === i.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, i))) : s = !1), !this.isUpdatePending && s && (this._$E_ = this._$Ej()) } async _$Ej() { this.isUpdatePending = !0; try { await this._$E_ } catch (t) { Promise.reject(t) } const t = this.scheduleUpdate(); return null != t && await t, !this.isUpdatePending } scheduleUpdate() { return this.performUpdate() } performUpdate() { var t; if (!this.isUpdatePending) return; this.hasUpdated, this._$Ei && (this._$Ei.forEach(((t, e) => this[e] = t)), this._$Ei = void 0); let e = !1; const i = this._$AL; try { e = this.shouldUpdate(i), e ? (this.willUpdate(i), null === (t = this._$ES) || void 0 === t || t.forEach((t => { var e; return null === (e = t.hostUpdate) || void 0 === e ? void 0 : e.call(t) })), this.update(i)) : this._$Ek() } catch (t) { throw e = !1, this._$Ek(), t } e && this._$AE(i) } willUpdate(t) { } _$AE(t) { var e; null === (e = this._$ES) || void 0 === e || e.forEach((t => { var e; return null === (e = t.hostUpdated) || void 0 === e ? void 0 : e.call(t) })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t) } _$Ek() { this._$AL = new Map, this.isUpdatePending = !1 } get updateComplete() { return this.getUpdateComplete() } getUpdateComplete() { return this._$E_ } shouldUpdate(t) { return !0 } update(t) { void 0 !== this._$EC && (this._$EC.forEach(((t, e) => this._$EO(e, this[e], t))), this._$EC = void 0), this._$Ek() } updated(t) { } firstUpdated(t) { } }
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var f; d.finalized = !0, d.elementProperties = new Map, d.elementStyles = [], d.shadowRootOptions = { mode: "open" }, null == c || c({ ReactiveElement: d }), (null !== (n = globalThis.reactiveElementVersions) && void 0 !== n ? n : globalThis.reactiveElementVersions = []).push("1.3.3"); const m = globalThis.trustedTypes, g = m ? m.createPolicy("lit-html", { createHTML: t => t }) : void 0, y = `lit$${(Math.random() + "").slice(9)}$`, v = "?" + y, b = `<${v}>`, k = document, _ = (t = "") => k.createComment(t), S = t => null === t || "object" != typeof t && "function" != typeof t, P = Array.isArray, w = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, x = /-->/g, $ = />/g, C = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, E = /'/g, A = /"/g, L = /^(?:script|style|textarea|title)$/i, O = (t => (e, ...i) => ({ _$litType$: t, strings: e, values: i }))(1), I = Symbol.for("lit-noChange"), N = Symbol.for("lit-nothing"), R = new WeakMap, M = k.createTreeWalker(k, 129, null, !1), D = (t, e) => { const i = t.length - 1, s = []; let r, o = 2 === e ? "<svg>" : "", n = w; for (let e = 0; e < i; e++) { const i = t[e]; let a, l, c = -1, h = 0; for (; h < i.length && (n.lastIndex = h, l = n.exec(i), null !== l);)h = n.lastIndex, n === w ? "!--" === l[1] ? n = x : void 0 !== l[1] ? n = $ : void 0 !== l[2] ? (L.test(l[2]) && (r = RegExp("</" + l[2], "g")), n = C) : void 0 !== l[3] && (n = C) : n === C ? ">" === l[0] ? (n = null != r ? r : w, c = -1) : void 0 === l[1] ? c = -2 : (c = n.lastIndex - l[2].length, a = l[1], n = void 0 === l[3] ? C : '"' === l[3] ? A : E) : n === A || n === E ? n = C : n === x || n === $ ? n = w : (n = C, r = void 0); const p = n === C && t[e + 1].startsWith("/>") ? " " : ""; o += n === w ? i + b : c >= 0 ? (s.push(a), i.slice(0, c) + "$lit$" + i.slice(c) + y + p) : i + y + (-2 === c ? (s.push(void 0), e) : p) } const a = o + (t[i] || "<?>") + (2 === e ? "</svg>" : ""); if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array"); return [void 0 !== g ? g.createHTML(a) : a, s] }; class B { constructor({ strings: t, _$litType$: e }, i) { let s; this.parts = []; let r = 0, o = 0; const n = t.length - 1, a = this.parts, [l, c] = D(t, e); if (this.el = B.createElement(l, i), M.currentNode = this.el.content, 2 === e) { const t = this.el.content, e = t.firstChild; e.remove(), t.append(...e.childNodes) } for (; null !== (s = M.nextNode()) && a.length < n;) { if (1 === s.nodeType) { if (s.hasAttributes()) { const t = []; for (const e of s.getAttributeNames()) if (e.endsWith("$lit$") || e.startsWith(y)) { const i = c[o++]; if (t.push(e), void 0 !== i) { const t = s.getAttribute(i.toLowerCase() + "$lit$").split(y), e = /([.?@])?(.*)/.exec(i); a.push({ type: 1, index: r, name: e[2], strings: t, ctor: "." === e[1] ? z : "?" === e[1] ? F : "@" === e[1] ? q : U }) } else a.push({ type: 6, index: r }) } for (const e of t) s.removeAttribute(e) } if (L.test(s.tagName)) { const t = s.textContent.split(y), e = t.length - 1; if (e > 0) { s.textContent = m ? m.emptyScript : ""; for (let i = 0; i < e; i++)s.append(t[i], _()), M.nextNode(), a.push({ type: 2, index: ++r }); s.append(t[e], _()) } } } else if (8 === s.nodeType) if (s.data === v) a.push({ type: 2, index: r }); else { let t = -1; for (; -1 !== (t = s.data.indexOf(y, t + 1));)a.push({ type: 7, index: r }), t += y.length - 1 } r++ } } static createElement(t, e) { const i = k.createElement("template"); return i.innerHTML = t, i } } function j(t, e, i = t, s) { var r, o, n, a; if (e === I) return e; let l = void 0 !== s ? null === (r = i._$Cl) || void 0 === r ? void 0 : r[s] : i._$Cu; const c = S(e) ? void 0 : e._$litDirective$; return (null == l ? void 0 : l.constructor) !== c && (null === (o = null == l ? void 0 : l._$AO) || void 0 === o || o.call(l, !1), void 0 === c ? l = void 0 : (l = new c(t), l._$AT(t, i, s)), void 0 !== s ? (null !== (n = (a = i)._$Cl) && void 0 !== n ? n : a._$Cl = [])[s] = l : i._$Cu = l), void 0 !== l && (e = j(t, l._$AS(t, e.values), l, s)), e } class H { constructor(t, e) { this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = e } get parentNode() { return this._$AM.parentNode } get _$AU() { return this._$AM._$AU } p(t) { var e; const { el: { content: i }, parts: s } = this._$AD, r = (null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e ? e : k).importNode(i, !0); M.currentNode = r; let o = M.nextNode(), n = 0, a = 0, l = s[0]; for (; void 0 !== l;) { if (n === l.index) { let e; 2 === l.type ? e = new T(o, o.nextSibling, this, t) : 1 === l.type ? e = new l.ctor(o, l.name, l.strings, this, t) : 6 === l.type && (e = new K(o, this, t)), this.v.push(e), l = s[++a] } n !== (null == l ? void 0 : l.index) && (o = M.nextNode(), n++) } return r } m(t) { let e = 0; for (const i of this.v) void 0 !== i && (void 0 !== i.strings ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++ } } class T { constructor(t, e, i, s) { var r; this.type = 2, this._$AH = N, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = s, this._$Cg = null === (r = null == s ? void 0 : s.isConnected) || void 0 === r || r } get _$AU() { var t, e; return null !== (e = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== e ? e : this._$Cg } get parentNode() { let t = this._$AA.parentNode; const e = this._$AM; return void 0 !== e && 11 === t.nodeType && (t = e.parentNode), t } get startNode() { return this._$AA } get endNode() { return this._$AB } _$AI(t, e = this) { t = j(this, t, e), S(t) ? t === N || null == t || "" === t ? (this._$AH !== N && this._$AR(), this._$AH = N) : t !== this._$AH && t !== I && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : (t => { var e; return P(t) || "function" == typeof (null === (e = t) || void 0 === e ? void 0 : e[Symbol.iterator]) })(t) ? this.S(t) : this.$(t) } M(t, e = this._$AB) { return this._$AA.parentNode.insertBefore(t, e) } k(t) { this._$AH !== t && (this._$AR(), this._$AH = this.M(t)) } $(t) { this._$AH !== N && S(this._$AH) ? this._$AA.nextSibling.data = t : this.k(k.createTextNode(t)), this._$AH = t } T(t) { var e; const { values: i, _$litType$: s } = t, r = "number" == typeof s ? this._$AC(t) : (void 0 === s.el && (s.el = B.createElement(s.h, this.options)), s); if ((null === (e = this._$AH) || void 0 === e ? void 0 : e._$AD) === r) this._$AH.m(i); else { const t = new H(r, this), e = t.p(this.options); t.m(i), this.k(e), this._$AH = t } } _$AC(t) { let e = R.get(t.strings); return void 0 === e && R.set(t.strings, e = new B(t)), e } S(t) { P(this._$AH) || (this._$AH = [], this._$AR()); const e = this._$AH; let i, s = 0; for (const r of t) s === e.length ? e.push(i = new T(this.M(_()), this.M(_()), this, this.options)) : i = e[s], i._$AI(r), s++; s < e.length && (this._$AR(i && i._$AB.nextSibling, s), e.length = s) } _$AR(t = this._$AA.nextSibling, e) { var i; for (null === (i = this._$AP) || void 0 === i || i.call(this, !1, !0, e); t && t !== this._$AB;) { const e = t.nextSibling; t.remove(), t = e } } setConnected(t) { var e; void 0 === this._$AM && (this._$Cg = t, null === (e = this._$AP) || void 0 === e || e.call(this, t)) } } class U { constructor(t, e, i, s, r) { this.type = 1, this._$AH = N, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, i.length > 2 || "" !== i[0] || "" !== i[1] ? (this._$AH = Array(i.length - 1).fill(new String), this.strings = i) : this._$AH = N } get tagName() { return this.element.tagName } get _$AU() { return this._$AM._$AU } _$AI(t, e = this, i, s) { const r = this.strings; let o = !1; if (void 0 === r) t = j(this, t, e, 0), o = !S(t) || t !== this._$AH && t !== I, o && (this._$AH = t); else { const s = t; let n, a; for (t = r[0], n = 0; n < r.length - 1; n++)a = j(this, s[i + n], e, n), a === I && (a = this._$AH[n]), o || (o = !S(a) || a !== this._$AH[n]), a === N ? t = N : t !== N && (t += (null != a ? a : "") + r[n + 1]), this._$AH[n] = a } o && !s && this.C(t) } C(t) { t === N ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "") } } class z extends U { constructor() { super(...arguments), this.type = 3 } C(t) { this.element[this.name] = t === N ? void 0 : t } } const V = m ? m.emptyScript : ""; class F extends U { constructor() { super(...arguments), this.type = 4 } C(t) { t && t !== N ? this.element.setAttribute(this.name, V) : this.element.removeAttribute(this.name) } } class q extends U { constructor(t, e, i, s, r) { super(t, e, i, s, r), this.type = 5 } _$AI(t, e = this) { var i; if ((t = null !== (i = j(this, t, e, 0)) && void 0 !== i ? i : N) === I) return; const s = this._$AH, r = t === N && s !== N || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, o = t !== N && (s === N || r); r && this.element.removeEventListener(this.name, this, s), o && this.element.addEventListener(this.name, this, t), this._$AH = t } handleEvent(t) { var e, i; "function" == typeof this._$AH ? this._$AH.call(null !== (i = null === (e = this.options) || void 0 === e ? void 0 : e.host) && void 0 !== i ? i : this.element, t) : this._$AH.handleEvent(t) } } class K { constructor(t, e, i) { this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i } get _$AU() { return this._$AM._$AU } _$AI(t) { j(this, t) } } const G = window.litHtmlPolyfillSupport;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Z, W; null == G || G(B, T), (null !== (f = globalThis.litHtmlVersions) && void 0 !== f ? f : globalThis.litHtmlVersions = []).push("2.2.6"); class J extends d { constructor() { super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0 } createRenderRoot() { var t, e; const i = super.createRenderRoot(); return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = i.firstChild), i } update(t) { const e = this.render(); this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ((t, e, i) => { var s, r; const o = null !== (s = null == i ? void 0 : i.renderBefore) && void 0 !== s ? s : e; let n = o._$litPart$; if (void 0 === n) { const t = null !== (r = null == i ? void 0 : i.renderBefore) && void 0 !== r ? r : null; o._$litPart$ = n = new T(e.insertBefore(_(), t), t, void 0, null != i ? i : {}) } return n._$AI(t), n })(e, this.renderRoot, this.renderOptions) } connectedCallback() { var t; super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0) } disconnectedCallback() { var t; super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1) } render() { return I } } J.finalized = !0, J._$litElement$ = !0, null === (Z = globalThis.litElementHydrateSupport) || void 0 === Z || Z.call(globalThis, { LitElement: J }); const Y = globalThis.litElementPolyfillSupport; null == Y || Y({ LitElement: J }), (null !== (W = globalThis.litElementVersions) && void 0 !== W ? W : globalThis.litElementVersions = []).push("3.2.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const X = t => e => "function" == typeof e ? ((t, e) => (window.customElements.define(t, e), e))(t, e) : ((t, e) => { const { kind: i, elements: s } = e; return { kind: i, elements: s, finisher(e) { window.customElements.define(t, e) } } })(t, e)
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */, Q = (t, e) => "method" === e.kind && e.descriptor && !("value" in e.descriptor) ? { ...e, finisher(i) { i.createProperty(e.key, t) } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e.key, initializer() { "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this)) }, finisher(i) { i.createProperty(e.key, t) } }; function tt(t) {
    return (e, i) => void 0 !== i ? ((t, e, i) => { e.constructor.createProperty(i, t) })(t, e, i) : Q(t, e)
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */} function et(t) { return tt({ ...t, state: !0 }) }
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */const it = ({ finisher: t, descriptor: e }) => (i, s) => { var r; if (void 0 === s) { const s = null !== (r = i.originalKey) && void 0 !== r ? r : i.key, o = null != e ? { kind: "method", placement: "prototype", key: s, descriptor: e(i.key) } : { ...i, key: s }; return null != t && (o.finisher = function (e) { t(e, s) }), o } { const r = i.constructor; void 0 !== e && Object.defineProperty(i, s, e(s)), null == t || t(r, s) } }
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */; function st(t, e) { return it({ descriptor: i => { const s = { get() { var e, i; return null !== (i = null === (e = this.renderRoot) || void 0 === e ? void 0 : e.querySelector(t)) && void 0 !== i ? i : null }, enumerable: !0, configurable: !0 }; if (e) { const e = "symbol" == typeof i ? Symbol() : "__" + i; s.get = function () { var i, s; return void 0 === this[e] && (this[e] = null !== (s = null === (i = this.renderRoot) || void 0 === i ? void 0 : i.querySelector(t)) && void 0 !== s ? s : null), this[e] } } return s } }) }
 /**
  * @license
  * Copyright 2021 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */var rt; null === (rt = window.HTMLSlotElement) || void 0 === rt || rt.prototype.assignedElements;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class ot extends Event { constructor(t, e, i) { super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.callback = e, this.subscribe = i } }
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class nt { constructor(t, e, i, s = !1) { this.host = t, this.context = e, this.callback = i, this.subscribe = s, this.provided = !1, this.value = void 0, this.host.addController(this) } hostConnected() { this.dispatchRequest() } hostDisconnected() { this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0) } dispatchRequest() { this.host.dispatchEvent(new ot(this.context, ((t, e) => { this.unsubscribe && (this.unsubscribe !== e && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = t, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(t, e)), this.unsubscribe = e }), this.subscribe)) } }
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class at extends Event { constructor(t) { super("context-provider", { bubbles: !0, composed: !0 }), this.context = t } } class lt extends class { constructor(t) { this.callbacks = new Map, this.updateObservers = () => { for (const [t, e] of this.callbacks) t(this.t, e) }, void 0 !== t && (this.value = t) } get value() { return this.t } set value(t) { this.setValue(t) } setValue(t, e = !1) { const i = e || !Object.is(t, this.t); this.t = t, i && this.updateObservers() } addCallback(t, e) { e && (this.callbacks.has(t) || this.callbacks.set(t, (() => { this.callbacks.delete(t) }))), t(this.value) } clearCallbacks() { this.callbacks.clear() } }{ constructor(t, e, i) { super(i), this.host = t, this.context = e, this.onContextRequest = t => { t.context === this.context && t.composedPath()[0] !== this.host && (t.stopPropagation(), this.addCallback(t.callback, t.subscribe)) }, this.host.addController(this), this.attachListeners() } attachListeners() { this.host.addEventListener("context-request", this.onContextRequest) } hostConnected() { this.host.dispatchEvent(new at(this.context)) } }
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */const ct = t => class extends t { constructor() { super(...arguments), this.isConfigLoaded = new Promise((t => { this.configLoadedResolve = t })), this.configuration = new nt(this, "configuration", (async () => { await this.setAttributesFromConfig(), this.configLoadedResolve && this.configLoadedResolve() }), !0) } loadConfig() { return this.isConfigLoaded } firstUpdated() { this.configuration.value || this.configLoadedResolve && this.configLoadedResolve() } async setAttributesFromConfig() { if (!this.configuration.value) return; const t = await this.configuration.value, e = new Map; for (const i of t.components) { const t = this.tagName.toLowerCase() === i.tagName, s = !i.cssSelector || this.matches(i.cssSelector); if (t && s) for (const [t, s] of Object.entries(i.attributes)) e.set(t, s) } for (const [t, i] of e) this.setAttribute(t, i) } }; class ht extends (ct(J)) { static { this.version = "0.0.1" } getGmpComponentsInventory() { return [] } } var pt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let ut = class extends ht { constructor() { super(); const t = this.querySelector('script[slot="data"]'); if (t?.textContent) return void (this.configuration = Promise.resolve(JSON.parse(t.textContent))); const e = this.getAttribute("src"); e && (this.configuration = this.loadJsonFromSrc(e)) } loadJsonFromSrc(t) { return fetch(t).then((t => t.ok && t.json())).then((t => t.record)) } render() { return O`<slot></slot>` } }; pt([function ({ context: t }) { return it({ finisher: (e, i) => { const s = new WeakMap; e.addInitializer((e => { s.set(e, new lt(e, t)) })); const r = Object.getOwnPropertyDescriptor(e.prototype, i), o = null == r ? void 0 : r.set, n = { ...r, set: function (t) { var e; null === (e = s.get(this)) || void 0 === e || e.setValue(t), o && o.call(this, t) } }; Object.defineProperty(e.prototype, i, n) } }) }({ context: "configuration" }), et()], ut.prototype, "configuration", void 0), ut = pt([X("gmp-configurator")], ut); var dt, ft = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let mt, gt; const yt = new Promise(((t, e) => { mt = t, gt = e })); let vt; let bt = dt = class extends ht { constructor() { super(...arguments), this.key = "", this.version = "weekly", this.libraries = ["drawing", "geometry", "places", "visualization"], this.language = "en", this.region = "US" } static getInstance() { return dt.instance } async connectedCallback() { if (super.connectedCallback(), dt.instance) return void console.warn("More than one <gmp-api-loader> element is present on this page. The Google Maps JavaScript API can only be fetched once."); dt.instance = this, vt && window.clearTimeout(vt), await this.loadConfig(); const t = this.createApiScriptEl(); t.addEventListener("load", (() => { mt(google.maps) })), t.addEventListener("error", gt), document.body.appendChild(t) } createApiScriptEl() { const t = document.createElement("script"), e = new URLSearchParams({ v: this.version, key: this.key, libraries: this.libraries.join(","), language: this.language, region: this.region }); return t.src = `https://maps.googleapis.com/maps/api/js?${e.toString()}`, t.async = !0, t.defer = !0, t } render() { return O`<slot></slot>` } static getGoogleMaps(t) { return dt.getInstance() || vt || (vt = window.setTimeout((() => { console.error(`${t} needs a GMP Api Loader to function correctly. Please make sure you have a <gmp-api-loader> element on the page.`) }), 5e3)), yt } }; ft([tt()], bt.prototype, "key", void 0), ft([tt()], bt.prototype, "version", void 0), ft([tt({ converter: { fromAttribute: t => t.split(/\s+/).filter((t => "" !== t)), toAttribute: t => t.join(" ") } })], bt.prototype, "libraries", void 0), ft([tt()], bt.prototype, "language", void 0), ft([tt()], bt.prototype, "region", void 0), bt = dt = ft([X("gmp-api-loader")], bt); var kt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let _t = class extends J { constructor() { super(...arguments), this.travelMode = "driving" } static { this.styles = r`.background:hover{fill:rgba(116,120,127,.1)}.background{fill:rgba(255,255,255,.01)}` } buildDirectionsUrl() { const t = new URLSearchParams("api=1"); return this.originPlaceId && t.append("origin_place_id", this.originPlaceId), this._hasOriginLatLng() ? t.append("origin", `${this.originLat},${this.originLng}`) : this.originAddress && t.append("origin", this.originAddress), this.destinationPlaceId && t.append("destination_place_id", this.destinationPlaceId), this._hasDestinationLatLng() ? t.append("destination", `${this.destinationLat},${this.destinationLng}`) : this.destinationAddress && t.append("destination", this.destinationAddress), t.append("travelmode", this.travelMode), "https://www.google.com/maps/dir/?" + t.toString() } _hasOriginLatLng() { return !!this.originLat && !!this.originLng } _hasDestinationLatLng() { return !!this.destinationLat && !!this.destinationLng } render() { return O`<a href="${this.buildDirectionsUrl()}" target="_blank" title="Get directions on Google Maps"><slot><svg width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5867 9.24375L17.9403 8.8902V8.8902L17.5867 9.24375ZM16.4117 9.24375L16.7653 9.59731L16.7675 9.59502L16.4117 9.24375ZM8.91172 16.7437L8.55817 16.3902L8.91172 16.7437ZM8.91172 17.9229L8.55817 18.2765L8.55826 18.2766L8.91172 17.9229ZM16.4117 25.4187H16.9117V25.2116L16.7652 25.0651L16.4117 25.4187ZM16.4117 25.4229H15.9117V25.63L16.0582 25.7765L16.4117 25.4229ZM25.0909 17.9229L25.4444 18.2765L25.4467 18.2742L25.0909 17.9229ZM25.4403 16.3902L17.9403 8.8902L17.2332 9.5973L24.7332 17.0973L25.4403 16.3902ZM17.9403 8.8902C17.4213 8.3712 16.5737 8.3679 16.0559 8.89248L16.7675 9.59502C16.8914 9.4696 17.1022 9.4663 17.2332 9.5973L17.9403 8.8902ZM16.0582 8.8902L8.55817 16.3902L9.26527 17.0973L16.7653 9.5973L16.0582 8.8902ZM8.55817 16.3902C8.0379 16.9105 8.0379 17.7562 8.55817 18.2765L9.26527 17.5694C9.13553 17.4396 9.13553 17.227 9.26527 17.0973L8.55817 16.3902ZM8.55826 18.2766L16.0583 25.7724L16.7652 25.0651L9.26517 17.5693L8.55826 18.2766ZM15.9117 25.4187V25.4229H16.9117V25.4187H15.9117ZM16.0582 25.7765C16.5784 26.2967 17.4242 26.2967 17.9444 25.7765L17.2373 25.0694C17.1076 25.1991 16.895 25.1991 16.7653 25.0694L16.0582 25.7765ZM17.9444 25.7765L25.4444 18.2765L24.7373 17.5694L17.2373 25.0694L17.9444 25.7765ZM25.4467 18.2742C25.9631 17.7512 25.9663 16.9096 25.438 16.3879L24.7354 17.0995C24.8655 17.2279 24.8687 17.4363 24.7351 17.5716L25.4467 18.2742Z" fill="#1967d2"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 19.8333V17.75H15.6667V20.25H14V16.9167C14 16.4542 14.3708 16.0833 14.8333 16.0833H19V14L21.9167 16.9167L19 19.8333Z" fill="#1967d2"/><circle class="background" cx="17" cy="17" r="16.5" stroke="#1967d2"/></svg></slot></a>` } }; kt([tt({ attribute: "origin-address" })], _t.prototype, "originAddress", void 0), kt([tt({ attribute: "origin-lat" })], _t.prototype, "originLat", void 0), kt([tt({ attribute: "origin-lng" })], _t.prototype, "originLng", void 0), kt([tt({ attribute: "origin-place-id" })], _t.prototype, "originPlaceId", void 0), kt([tt({ attribute: "destination-address" })], _t.prototype, "destinationAddress", void 0), kt([tt({ attribute: "destination-lat" })], _t.prototype, "destinationLat", void 0), kt([tt({ attribute: "destination-lng" })], _t.prototype, "destinationLng", void 0), kt([tt({ attribute: "destination-place-id" })], _t.prototype, "destinationPlaceId", void 0), kt([tt()], _t.prototype, "travelMode", void 0), _t = kt([X("gmp-directions-button")], _t); var St = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let Pt = class extends ht { async firstUpdated() { await bt.getGoogleMaps(this.tagName) } render() { return O`<p>This is a GMP component!</p>` } }; Pt = St([X("gmp-dummy-component")], Pt);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wt = 1, xt = 2, $t = t => (...e) => ({ _$litDirective$: t, values: e }); class Ct { constructor(t) { } get _$AU() { return this._$AM._$AU } _$AT(t, e, i) { this._$Ct = t, this._$AM = e, this._$Ci = i } _$AS(t, e) { return this.update(t, e) } update(t, e) { return this.render(...e) } }
 /**
  * @license
  * Copyright 2018 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */const Et = $t(class extends Ct { constructor(t) { var e; if (super(t), t.type !== wt || "class" !== t.name || (null === (e = t.strings) || void 0 === e ? void 0 : e.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.") } render(t) { return " " + Object.keys(t).filter((e => t[e])).join(" ") + " " } update(t, [e]) { var i, s; if (void 0 === this.et) { this.et = new Set, void 0 !== t.strings && (this.st = new Set(t.strings.join(" ").split(/\s/).filter((t => "" !== t)))); for (const t in e) e[t] && !(null === (i = this.st) || void 0 === i ? void 0 : i.has(t)) && this.et.add(t); return this.render(e) } const r = t.element.classList; this.et.forEach((t => { t in e || (r.remove(t), this.et.delete(t)) })); for (const t in e) { const i = !!e[t]; i === this.et.has(t) || (null === (s = this.st) || void 0 === s ? void 0 : s.has(t)) || (i ? (r.add(t), this.et.add(t)) : (r.remove(t), this.et.delete(t))) } return I } }), At = {}, Lt = $t(class extends Ct {
    constructor() { super(...arguments), this.key = N } render(t, e) { return this.key = t, e } update(t, [e, i]) {
        return e !== this.key && (((t, e = At) => {
            t._$AH = e;
 /**
  * @license
  * Copyright 2021 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */})(t), this.key = e), i
    }
});
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* Ot(t, e) { if (void 0 !== t) { let i = 0; for (const s of t) yield e(s, i++) } }
 /**
  * @license
  * Copyright 2021 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */function It(t, e, i) { return t ? e() : null == i ? void 0 : i() } class Nt { constructor(t) { (this.host = t).addController(this) } getDistanceMatrix(t) { return new Promise(((e, i) => { this.getService().getDistanceMatrix(t, ((t, s) => { s === google.maps.DistanceMatrixStatus.OK ? e(t) : i(s) })) })) } getService() { return this.service || (this.service = new google.maps.DistanceMatrixService), this.service } hostUpdate() { } } var Rt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let Mt = class extends ht { constructor() { super(...arguments), this.locations = [], this.distanceMatrixController = new Nt(this) } static { this.styles = r`gmp-place-search{background-color:#fff;left:0;padding:10px;position:sticky;top:0;z-index:1}gmp-place-item{cursor:pointer}gmp-place-item.selected,gmp-place-item:hover{background-color:rgba(60,64,67,.04)}` } async firstUpdated() { this.placeSearchEl.map = await this.mapEl.map } async handlePlaceSearchChange(t) { if (this.origin = t.detail, this.selectedIndex = void 0, !this.origin) return; const e = await this.distanceMatrixController.getDistanceMatrix({ origins: [this.origin.geometry.location], destinations: this.locations.map((t => t.geometry.location)), travelMode: google.maps.TravelMode.DRIVING }), i = this.locations.map(((t, i) => ({ location: t, distance: e.rows[0].elements[i].distance.value }))); this.locations = i.sort(((t, e) => t.distance - e.distance)).map((t => t.location)) } render() { return O`<gmp-sidebar-layout><div slot="sidebar"><gmp-place-search @placechanged="${this.handlePlaceSearchChange}"></gmp-place-search><gmp-responsive-list>${Ot(this.locations, ((t, e) => O`<gmp-place-item slot="li" .placeId="${t.place_id}" .data="${t}" class="${Et({ selected: this.selectedIndex === e })}" @click="${() => { this.selectedIndex = e }}"><gmp-directions-button slot="suffix" .originPlaceId="${this.origin?.place_id}" .originAddress="${this.origin?.formatted_address ?? this.origin?.vicinity}" .destinationPlaceId="${t.place_id}" .destinationAddress="${t.formatted_address ?? t.vicinity}"></gmp-directions-button></gmp-place-item>`))}</gmp-responsive-list></div><gmp-map slot="map"><gmp-map-marker-group fitbounds>${Ot(this.locations, ((t, e) => O`<gmp-map-marker .position="${t.geometry?.location}" .centered="${!this.origin && e === this.selectedIndex}" @click="${() => { this.selectedIndex = e }}"></gmp-map-marker>`))} ${It(this.origin, (() => Lt(this.origin, O`<gmp-map-marker class="origin" .position="${this.origin.geometry?.location}"></gmp-map-marker>`)))}</gmp-map-marker-group>${It(this.origin && void 0 !== this.selectedIndex, (() => O`<gmp-map-directions .origin="${{ placeId: this.origin.place_id }}" .destination="${{ placeId: this.locations[this.selectedIndex].place_id }}"></gmp-map-directions>`))}</gmp-map></gmp-sidebar-layout>` } }; Rt([tt({ type: Array })], Mt.prototype, "locations", void 0), Rt([tt({ type: Number })], Mt.prototype, "selectedIndex", void 0), Rt([tt({ type: Object })], Mt.prototype, "origin", void 0), Rt([st("gmp-map")], Mt.prototype, "mapEl", void 0), Rt([st("gmp-place-search")], Mt.prototype, "placeSearchEl", void 0), Mt = Rt([X("gmp-locator-solution")], Mt); class Dt extends Event { constructor() { super(Dt.eventName, { bubbles: !0, composed: !0 }) } static { this.eventName = "gmp-get-map" } } var Bt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let jt = class extends ht { constructor() { super(), this.options = {}, this.map = this.initializeMap(), this.addEventListener(Dt.eventName, (t => { t.gmpMap = this, t.stopPropagation() })) } static { this.styles = r`#map,:host{display:block;height:100%;width:100%}` } initializeMap() { return new Promise((async t => { await this.loadConfig(), t(new ((await bt.getGoogleMaps(this.tagName)).Map)(this.mapEl, this.options)) })) } async updated(t) { t.has("options") && (await this.map)?.setOptions(this.options) } render() { return O`<div id="map"></div><slot></slot>` } }; Bt([tt({ type: Object })], jt.prototype, "options", void 0), Bt([tt({ type: Object })], jt.prototype, "map", void 0), Bt([st("#map")], jt.prototype, "mapEl", void 0), jt = Bt([X("gmp-map")], jt); class Ht { constructor(t) { (this.host = t).addController(this) } route(t) { return new Promise(((e, i) => { this.getService().then((s => { s.route(t, ((t, s) => { s === google.maps.DirectionsStatus.OK ? e(t) : i(s) })) })) })) } async getService() { if (!this.service) { const t = await bt.getGoogleMaps(this.host.tagName); this.service = new t.DirectionsService } return this.service } hostUpdate() { } } const Tt = t => { class e extends t { static { this.styles = r`:host{display:none}` } connectedCallback() { super.connectedCallback(), this.mapComponent = this._getMapComponent(), this.mapReady = this.mapComponent.map, this.mapReady.then((t => { t !== this.map && (this.map && this.mapCleanupCallback(), this.map = t, this.mapReadyCallback()) })) } disconnectedCallback() { this.mapCleanupCallback(), super.disconnectedCallback() } _getMapComponent() { const t = new Dt; if (this.dispatchEvent(t), !t.gmpMap) throw new Error(`Component ${this.tagName} must be a descendant of <gmp-map>.`); return t.gmpMap } mapReadyCallback() { } mapCleanupCallback() { } } return e }; var Ut = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let zt = class extends (Tt(ht)) { constructor() { super(...arguments), this.renderers = [], this.travelMode = google.maps.TravelMode.DRIVING, this.directionsController = new Ht(this) } mapReadyCallback() { if (this.rendererOptions) for (const t of this.rendererOptions) this.renderers.push(new google.maps.DirectionsRenderer(t)), this.renderers[0].setMap(this.map ?? null); else this.renderers.push(new google.maps.DirectionsRenderer); for (const t of this.renderers) t.setMap(this.map ?? null) } mapCleanupCallback() { for (const t of this.renderers) t.setMap(null) } async updated(t) { if (t.has("origin") || t.has("destination")) { const t = await this.directionsController.route({ origin: this.origin, destination: this.destination, travelMode: this.travelMode }); for (const e of this.renderers) e.setDirections(t) } } }; Ut([tt({ attribute: !1 })], zt.prototype, "renderers", void 0), Ut([tt({ type: Array })], zt.prototype, "rendererOptions", void 0), Ut([tt({ type: Object })], zt.prototype, "origin", void 0), Ut([tt({ type: Object })], zt.prototype, "destination", void 0), Ut([tt({ type: String })], zt.prototype, "travelMode", void 0), zt = Ut([X("gmp-map-directions")], zt); var Vt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let Ft = class extends (Tt(ht)) { constructor() { super(...arguments), this.fitBounds = !1 } mapReadyCallback() { this.fitMapToBounds() } async fitMapToBounds() { if (!this.fitBounds || !this.map) return; const t = new google.maps.LatLngBounds; this.querySelectorAll("gmp-map-marker").forEach((e => { const { position: i } = e; i && t.extend(i) })), this.map.fitBounds(t) } render() { return O`<slot @slotchange="${this.fitMapToBounds}"></slot>` } }; Vt([tt({ type: Boolean })], Ft.prototype, "fitBounds", void 0), Ft = Vt([X("gmp-map-marker-group")], Ft); var qt = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; const Kt = [13, 36], Gt = [13, 13]; let Zt = class extends (Tt(ht)) { constructor() { super(...arguments), this.options = {}, this.background = "#ea4335", this.borderColor = "#c5221f", this.centered = !1 } async mapReadyCallback() { this.marker = new google.maps.Marker({ ...this.options, icon: await this.getPinIcon(), label: this.getLabelText() ?? this.getLabelIcon() ?? this.getDefaultIcon(), position: this.position, map: this.map }), this.marker.addListener("click", (() => { this.dispatchEvent(new Event("click")) })) } mapCleanupCallback() { this.marker?.setMap(null) } getLabelText() { if ("string" == typeof this.options.label) return this.labelText ?? this.options.label; const t = this.labelText ?? this.options.label?.text; return t ? { ...this.options.label, text: t } : void 0 } getLabelIcon() { return this.icon ? { color: "white", fontSize: "16px", fontFamily: "Material Icons", text: this.icon } : void 0 } getDefaultIcon() { return { color: this.borderColor, fontSize: "18px", text: "âš‰" } } async getPinIcon() { const t = await bt.getGoogleMaps(this.tagName); return { path: "M13 0C5.817 0 0 5.93 0 13.267c0 7.862 5.59 10.81 9.555 17.624C12.09 35.248 11.342 38 13 38c1.723 0 .975-2.817 3.445-7.043C20.085 24.503 26 21.162 26 13.267 26 5.93 20.183 0 13 0Z", fillColor: this.background, fillOpacity: 1, strokeColor: this.borderColor, anchor: new t.Point(...Kt), labelOrigin: new t.Point(...Gt) } } async updated(t) { if (t.has("options") && this.marker?.setOptions(this.options), t.has("position") && this.position && this.marker?.setPosition(this.position), (t.has("icon") || t.has("labelText")) && this.marker?.setLabel(this.getLabelText() ?? this.getLabelIcon() ?? this.getDefaultIcon()), (t.has("background") || t.has("borderColor")) && this.marker?.setIcon(await this.getPinIcon()), t.has("centered")) { const t = this.marker?.getPosition(); this.centered && t && this.map?.panTo(t) } } }; var Wt; qt([tt({ attribute: !1 })], Zt.prototype, "marker", void 0), qt([tt({ type: Object })], Zt.prototype, "options", void 0), qt([tt({ type: Object })], Zt.prototype, "position", void 0), qt([tt({ type: String, attribute: "label-text" })], Zt.prototype, "labelText", void 0), qt([tt({ type: String })], Zt.prototype, "icon", void 0), qt([tt({ type: String })], Zt.prototype, "background", void 0), qt([tt({ type: String, attribute: "border-color" })], Zt.prototype, "borderColor", void 0), qt([tt({ type: Boolean })], Zt.prototype, "centered", void 0), Zt = qt([X("gmp-map-marker")], Zt), function (t) { t.BASIC = "basic", t.CONTACT = "contact", t.ATOMOSPHERE = "atmosphere" }(Wt || (Wt = {})); const Jt = new Map, Yt = { [Wt.BASIC]: ["address_component", "adr_address", "business_status", "formatted_address", "geometry", "icon", "icon_mask_base_uri", "icon_background_color", "name", "photo", "place_id", "plus_code", "type", "url", "utc_offset_minutes", "vicinity"], [Wt.CONTACT]: ["formatted_phone_number", "international_phone_number", "opening_hours", "website"], [Wt.ATOMOSPHERE]: ["price_level", "rating", "review", "user_ratings_total"] }; class Xt { constructor(t) { (this.host = t).addController(this), this.attrContainer = document.createElement("div"), t.appendChild(this.attrContainer) } getDetails(t) { return new Promise(((e, i) => { this.getService().then((s => { s.getDetails(t, ((t, s) => { s === google.maps.places.PlacesServiceStatus.OK ? e(t) : i(s) })) })) })) } async getDetailsByPlaceAndFields(t, e) { const i = t.place_id; if (!i) return console.warn("Place ID is required to make a Place Details call."), t; let s = { ...Jt.get(i), ...t }; const r = e.filter((t => { const e = t.split(".")[0]; return !s[e] })); if (r.length > 0) { const t = await this.getDetails({ placeId: i, fields: r }); s = { ...s, ...t }, Jt.set(i, s) } return { ...s } } getDetailsByPlaceAndFieldCategories(t, e) { const i = []; for (const t of e) i.concat(Yt[t]); return this.getDetailsByPlaceAndFields(t, i) } async refreshPlaceId(t) { return (await this.getDetails({ placeId: t, fields: ["place_id"] })).place_id } getTypeLabel(t) { const e = t.types?.[0]; if (!e) return; return (e.charAt(0).toUpperCase() + e.slice(1)).replaceAll("_", " ") } getPriceLevelLabel(t) { return t.price_level ? "$".repeat(t.price_level) : void 0 } getSimplifiedAddress(t) { if (t.vicinity) return t.vicinity; const e = t.formatted_address; return e ? e.substring(0, e.indexOf(",")) : void 0 } async getService() { if (!this.service) { const t = await bt.getGoogleMaps(this.host.tagName); this.service = new t.places.PlacesService(this.attrContainer) } return this.service } hostUpdate() { } }
 /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */class Qt extends Ct { constructor(t) { if (super(t), this.it = N, t.type !== xt) throw Error(this.constructor.directiveName + "() can only be used in child bindings") } render(t) { if (t === N || null == t) return this.ft = void 0, this.it = t; if (t === I) return t; if ("string" != typeof t) throw Error(this.constructor.directiveName + "() called with a non-string value"); if (t === this.it) return this.ft; this.it = t; const e = [t]; return e.raw = e, this.ft = { _$litType$: this.constructor.resultType, strings: e, values: [] } } } Qt.directiveName = "unsafeHTML", Qt.resultType = 1; const te = $t(Qt), ee = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, ie = /[&<>"'`=]/g, se = /[&<>"'`=]/; function re(t) { return ee[t] } function oe(t) { for (let e = 1; e < arguments.length; e++)for (let i in arguments[e]) Object.prototype.hasOwnProperty.call(arguments[e], i) && (t[i] = arguments[e][i]); return t } let ne = Object.prototype.toString, ae = function (t) { return "function" == typeof t }; ae(/x/) && (ae = function (t) { return "function" == typeof t && "[object Function]" === ne.call(t) }); const le = Array.isArray || function (t) { return !(!t || "object" != typeof t) && "[object Array]" === ne.call(t) }; function ce(t, e) { for (let i = 0, s = t.length; i < s; i++)if (t[i] === e) return i; return -1 } function he(t) { if ("string" != typeof t) { if (t && t.toHTML) return t.toHTML(); if (null == t) return ""; if (!t) return t + ""; t = "" + t } return se.test(t) ? t.replace(ie, re) : t } function pe(t) { return !t && 0 !== t || !(!le(t) || 0 !== t.length) } function ue(t) { let e = oe({}, t); return e._parent = t, e } function de(t, e) { return t.path = e, t } function fe(t, e) { return (t ? t + "." : "") + e } var me = Object.freeze({ __proto__: null, extend: oe, toString: ne, get isFunction() { return ae }, isArray: le, indexOf: ce, escapeExpression: he, isEmpty: pe, createFrame: ue, blockParams: de, appendContextPath: fe }); const ge = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"]; function ye(t, e) { let i, s, r, o, n = e && e.loc; n && (i = n.start.line, s = n.end.line, r = n.start.column, o = n.end.column, t += " - " + i + ":" + r); let a = Error.prototype.constructor.call(this, t); for (let t = 0; t < ge.length; t++)this[ge[t]] = a[ge[t]]; Error.captureStackTrace && Error.captureStackTrace(this, ye); try { n && (this.lineNumber = i, this.endLineNumber = s, Object.defineProperty ? (Object.defineProperty(this, "column", { value: r, enumerable: !0 }), Object.defineProperty(this, "endColumn", { value: o, enumerable: !0 })) : (this.column = r, this.endColumn = o)) } catch (t) { } } function ve(t) { !function (t) { t.registerHelper("blockHelperMissing", (function (e, i) { let s = i.inverse, r = i.fn; if (!0 === e) return r(this); if (!1 === e || null == e) return s(this); if (le(e)) return e.length > 0 ? (i.ids && (i.ids = [i.name]), t.helpers.each(e, i)) : s(this); if (i.data && i.ids) { let t = ue(i.data); t.contextPath = fe(i.data.contextPath, i.name), i = { data: t } } return r(e, i) })) }(t), function (t) { t.registerHelper("each", (function (t, e) { if (!e) throw new ye("Must pass iterator to #each"); let i, s, r = e.fn, o = e.inverse, n = 0, a = ""; function l(e, o, n) { i && (i.key = e, i.index = o, i.first = 0 === o, i.last = !!n, s && (i.contextPath = s + e)), a += r(t[e], { data: i, blockParams: de([t[e], e], [s + e, null]) }) } if (e.data && e.ids && (s = fe(e.data.contextPath, e.ids[0]) + "."), ae(t) && (t = t.call(this)), e.data && (i = ue(e.data)), t && "object" == typeof t) if (le(t)) for (let e = t.length; n < e; n++)n in t && l(n, n, n === t.length - 1); else if (global.Symbol && t[global.Symbol.iterator]) { const e = [], i = t[global.Symbol.iterator](); for (let t = i.next(); !t.done; t = i.next())e.push(t.value); for (let i = (t = e).length; n < i; n++)l(n, n, n === t.length - 1) } else { let e; Object.keys(t).forEach((t => { void 0 !== e && l(e, n - 1), e = t, n++ })), void 0 !== e && l(e, n - 1, !0) } return 0 === n && (a = o(this)), a })) }(t), function (t) { t.registerHelper("helperMissing", (function () { if (1 !== arguments.length) throw new ye('Missing helper: "' + arguments[arguments.length - 1].name + '"') })) }(t), function (t) { t.registerHelper("if", (function (t, e) { if (2 != arguments.length) throw new ye("#if requires exactly one argument"); return ae(t) && (t = t.call(this)), !e.hash.includeZero && !t || pe(t) ? e.inverse(this) : e.fn(this) })), t.registerHelper("unless", (function (e, i) { if (2 != arguments.length) throw new ye("#unless requires exactly one argument"); return t.helpers.if.call(this, e, { fn: i.inverse, inverse: i.fn, hash: i.hash }) })) }(t), function (t) { t.registerHelper("log", (function () { let e = [void 0], i = arguments[arguments.length - 1]; for (let t = 0; t < arguments.length - 1; t++)e.push(arguments[t]); let s = 1; null != i.hash.level ? s = i.hash.level : i.data && null != i.data.level && (s = i.data.level), e[0] = s, t.log(...e) })) }(t), function (t) { t.registerHelper("lookup", (function (t, e, i) { return t ? i.lookupProperty(t, e) : t })) }(t), function (t) { t.registerHelper("with", (function (t, e) { if (2 != arguments.length) throw new ye("#with requires exactly one argument"); ae(t) && (t = t.call(this)); let i = e.fn; if (pe(t)) return e.inverse(this); { let s = e.data; return e.data && e.ids && (s = ue(e.data), s.contextPath = fe(e.data.contextPath, e.ids[0])), i(t, { data: s, blockParams: de([t], [s && s.contextPath]) }) } })) }(t) } function be(t, e, i) { t.helpers[e] && (t.hooks[e] = t.helpers[e], i || delete t.helpers[e]) } function ke(t) { !function (t) { t.registerDecorator("inline", (function (t, e, i, s) { let r = t; return e.partials || (e.partials = {}, r = function (s, r) { let o = i.partials; i.partials = oe({}, o, e.partials); let n = t(s, r); return i.partials = o, n }), e.partials[s.args[0]] = s.fn, r })) }(t) } ye.prototype = new Error; let _e = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: function (t) { if ("string" == typeof t) { let e = ce(_e.methodMap, t.toLowerCase()); t = e >= 0 ? e : parseInt(t, 10) } return t }, log: function (t, ...e) { if (t = _e.lookupLevel(t), "undefined" != typeof console && _e.lookupLevel(_e.level) <= t) { let i = _e.methodMap[t]; console[i] || (i = "log"), console[i](...e) } } }; function Se(...t) { return oe(Object.create(null), ...t) } const Pe = Object.create(null); function we(t, e) { return void 0 !== t.whitelist[e] ? !0 === t.whitelist[e] : void 0 !== t.defaultValue ? t.defaultValue : (function (t) { !0 !== Pe[t] && (Pe[t] = !0, (void 0)("error", `Handlebars: Access has been denied to resolve the property "${t}" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`)) }(e), !1) } const xe = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0 <4.3.0", 8: ">= 4.3.0" }; function $e(t, e, i) { this.helpers = t || {}, this.partials = e || {}, this.decorators = i || {}, ve(this), ke(this) } $e.prototype = { constructor: $e, logger: _e, log: _e.log, registerHelper: function (t, e) { if ("[object Object]" === ne.call(t)) { if (e) throw new ye("Arg not supported with multiple helpers"); oe(this.helpers, t) } else this.helpers[t] = e }, unregisterHelper: function (t) { delete this.helpers[t] }, registerPartial: function (t, e) { if ("[object Object]" === ne.call(t)) oe(this.partials, t); else { if (void 0 === e) throw new ye(`Attempting to register a partial called "${t}" as undefined`); this.partials[t] = e } }, unregisterPartial: function (t) { delete this.partials[t] }, registerDecorator: function (t, e) { if ("[object Object]" === ne.call(t)) { if (e) throw new ye("Arg not supported with multiple decorators"); oe(this.decorators, t) } else this.decorators[t] = e }, unregisterDecorator: function (t) { delete this.decorators[t] }, resetLoggedPropertyAccesses() { Object.keys(Pe).forEach((t => { delete Pe[t] })) } }; let Ce = _e.log; var Ee = Object.freeze({ __proto__: null, VERSION: "4.7.7", COMPILER_REVISION: 8, LAST_COMPATIBLE_COMPILER_REVISION: 7, REVISION_CHANGES: xe, HandlebarsEnvironment: $e, log: Ce, createFrame: ue, logger: _e }); function Ae(t) { this.string = t } function Le(t, e) { if (!e) throw new ye("No environment passed to template"); if (!t || !t.main) throw new ye("Unknown template object: " + typeof t); t.main.decorator = t.main_d, e.VM.checkRevision(t.compiler); const i = t.compiler && 7 === t.compiler[0]; let s = { strict: function (t, e, i) { if (!t || !(e in t)) throw new ye('"' + e + '" not defined in ' + t, { loc: i }); return s.lookupProperty(t, e) }, lookupProperty: function (t, e) { let i = t[e]; return null == i || Object.prototype.hasOwnProperty.call(t, e) || function (t, e, i) { return we("function" == typeof t ? e.methods : e.properties, i) }(i, s.protoAccessControl, e) ? i : void 0 }, lookup: function (t, e) { const i = t.length; for (let r = 0; r < i; r++) { if (null != (t[r] && s.lookupProperty(t[r], e))) return t[r][e] } }, lambda: function (t, e) { return "function" == typeof t ? t.call(e) : t }, escapeExpression: he, invokePartial: function (i, s, r) { r.hash && (s = oe({}, s, r.hash), r.ids && (r.ids[0] = !0)), i = e.VM.resolvePartial.call(this, i, s, r); let o = oe({}, r, { hooks: this.hooks, protoAccessControl: this.protoAccessControl }), n = e.VM.invokePartial.call(this, i, s, o); if (null == n && e.compile && (r.partials[r.name] = e.compile(i, t.compilerOptions, e), n = r.partials[r.name](s, o)), null != n) { if (r.indent) { let t = n.split("\n"); for (let e = 0, i = t.length; e < i && (t[e] || e + 1 !== i); e++)t[e] = r.indent + t[e]; n = t.join("\n") } return n } throw new ye("The partial " + r.name + " could not be compiled when running in runtime-only mode") }, fn: function (e) { let i = t[e]; return i.decorator = t[e + "_d"], i }, programs: [], program: function (t, e, i, s, r) { let o = this.programs[t], n = this.fn(t); return e || r || s || i ? o = Oe(this, t, n, e, i, s, r) : o || (o = this.programs[t] = Oe(this, t, n)), o }, data: function (t, e) { for (; t && e--;)t = t._parent; return t }, mergeIfNeeded: function (t, e) { let i = t || e; return t && e && t !== e && (i = oe({}, e, t)), i }, nullContext: Object.seal({}), noop: e.VM.noop, compilerInfo: t.compiler }; function r(e, i = {}) { let o = i.data; r._setup(i), !i.partial && t.useData && (o = function (t, e) { e && "root" in e || ((e = e ? ue(e) : {}).root = t); return e }(e, o)); let n, a = t.useBlockParams ? [] : void 0; function l(e) { return "" + t.main(s, e, s.helpers, s.partials, o, a, n) } return t.useDepths && (n = i.depths ? e != i.depths[0] ? [e].concat(i.depths) : i.depths : [e]), (l = Ne(t.main, l, s, i.depths || [], o, a))(e, i) } return r.isTop = !0, r._setup = function (r) { if (r.partial) s.protoAccessControl = r.protoAccessControl, s.helpers = r.helpers, s.partials = r.partials, s.decorators = r.decorators, s.hooks = r.hooks; else { let o = oe({}, e.helpers, r.helpers); !function (t, e) { Object.keys(t).forEach((i => { let s = t[i]; t[i] = function (t, e) { const i = e.lookupProperty; return function (t, e) { return "function" != typeof t ? t : function () { return arguments[arguments.length - 1] = e(arguments[arguments.length - 1]), t.apply(this, arguments) } }(t, (t => oe({ lookupProperty: i }, t))) }(s, e) })) }(o, s), s.helpers = o, t.usePartial && (s.partials = s.mergeIfNeeded(r.partials, e.partials)), (t.usePartial || t.useDecorators) && (s.decorators = oe({}, e.decorators, r.decorators)), s.hooks = {}, s.protoAccessControl = function (t) { let e = Object.create(null); e.constructor = !1, e.__defineGetter__ = !1, e.__defineSetter__ = !1, e.__lookupGetter__ = !1; let i = Object.create(null); return i.__proto__ = !1, { properties: { whitelist: Se(i, t.allowedProtoProperties), defaultValue: t.allowProtoPropertiesByDefault }, methods: { whitelist: Se(e, t.allowedProtoMethods), defaultValue: t.allowProtoMethodsByDefault } } }(r); let n = r.allowCallsToHelperMissing || i; be(s, "helperMissing", n), be(s, "blockHelperMissing", n) } }, r._child = function (e, i, r, o) { if (t.useBlockParams && !r) throw new ye("must pass block params"); if (t.useDepths && !o) throw new ye("must pass parent depths"); return Oe(s, e, t[e], i, 0, r, o) }, r } function Oe(t, e, i, s, r, o, n) { function a(e, r = {}) { let a = n; return !n || e == n[0] || e === t.nullContext && null === n[0] || (a = [e].concat(n)), i(t, e, t.helpers, t.partials, r.data || s, o && [r.blockParams].concat(o), a) } return (a = Ne(i, a, t, n, s, o)).program = e, a.depth = n ? n.length : 0, a.blockParams = r || 0, a } function Ie() { return "" } function Ne(t, e, i, s, r, o) { if (t.decorator) { let n = {}; oe(e = t.decorator(e, n, i, s && s[0], r, o, s), n) } return e } Ae.prototype.toString = Ae.prototype.toHTML = function () { return "" + this.string }; var Re = Object.freeze({ __proto__: null, checkRevision: function (t) { const e = t && t[0] || 1; if (!(e >= 7 && e <= 8)) { if (e < 7) { throw new ye("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + xe[8] + ") or downgrade your runtime to an older version (" + xe[e] + ").") } throw new ye("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + t[1] + ").") } }, template: Le, wrapProgram: Oe, resolvePartial: function (t, e, i) { return t ? t.call || i.name || (i.name = t, t = i.partials[t]) : t = "@partial-block" === i.name ? i.data["partial-block"] : i.partials[i.name], t }, invokePartial: function (t, e, i) { const s = i.data && i.data["partial-block"]; let r; if (i.partial = !0, i.ids && (i.data.contextPath = i.ids[0] || i.data.contextPath), i.fn && i.fn !== Ie) { i.data = ue(i.data); let t = i.fn; r = i.data["partial-block"] = function (e, i = {}) { return i.data = ue(i.data), i.data["partial-block"] = s, t(e, i) }, t.partials && (i.partials = oe({}, i.partials, t.partials)) } if (void 0 === t && r && (t = r), void 0 === t) throw new ye("The partial " + i.name + " could not be found"); if (t instanceof Function) return t(e, i) }, noop: Ie }); function Me(t) { let e = "undefined" != typeof global ? global : window, i = e.Handlebars; t.noConflict = function () { return e.Handlebars === t && (e.Handlebars = i), t } } function De() { let t = new $e; return oe(t, Ee), t.SafeString = Ae, t.Exception = ye, t.Utils = me, t.escapeExpression = he, t.VM = Re, t.template = function (e) { return Le(e, t) }, t } let Be = De(); Be.create = De, Me(Be), Be.default = Be; let je = { helpers: { helperExpression: function (t) { return "SubExpression" === t.type || ("MustacheStatement" === t.type || "BlockStatement" === t.type) && !!(t.params && t.params.length || t.hash) }, scopedId: function (t) { return /^\.|this\b/.test(t.original) }, simpleId: function (t) { return 1 === t.parts.length && !je.helpers.scopedId(t) && !t.depth } } }; var He = function () { var t = { trace: function () { }, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: function (t, e, i, s, r, o, n) { var a = o.length - 1; switch (r) { case 1: return o[a - 1]; case 2: this.$ = s.prepareProgram(o[a]); break; case 3: case 4: case 5: case 6: case 7: case 8: case 20: case 27: case 28: case 33: case 34: case 40: case 41: this.$ = o[a]; break; case 9: this.$ = { type: "CommentStatement", value: s.stripComment(o[a]), strip: s.stripFlags(o[a], o[a]), loc: s.locInfo(this._$) }; break; case 10: this.$ = { type: "ContentStatement", original: o[a], value: o[a], loc: s.locInfo(this._$) }; break; case 11: this.$ = s.prepareRawBlock(o[a - 2], o[a - 1], o[a], this._$); break; case 12: this.$ = { path: o[a - 3], params: o[a - 2], hash: o[a - 1] }; break; case 13: this.$ = s.prepareBlock(o[a - 3], o[a - 2], o[a - 1], o[a], !1, this._$); break; case 14: this.$ = s.prepareBlock(o[a - 3], o[a - 2], o[a - 1], o[a], !0, this._$); break; case 15: this.$ = { open: o[a - 5], path: o[a - 4], params: o[a - 3], hash: o[a - 2], blockParams: o[a - 1], strip: s.stripFlags(o[a - 5], o[a]) }; break; case 16: case 17: this.$ = { path: o[a - 4], params: o[a - 3], hash: o[a - 2], blockParams: o[a - 1], strip: s.stripFlags(o[a - 5], o[a]) }; break; case 18: this.$ = { strip: s.stripFlags(o[a - 1], o[a - 1]), program: o[a] }; break; case 19: var l = s.prepareBlock(o[a - 2], o[a - 1], o[a], o[a], !1, this._$), c = s.prepareProgram([l], o[a - 1].loc); c.chained = !0, this.$ = { strip: o[a - 2].strip, program: c, chain: !0 }; break; case 21: this.$ = { path: o[a - 1], strip: s.stripFlags(o[a - 2], o[a]) }; break; case 22: case 23: this.$ = s.prepareMustache(o[a - 3], o[a - 2], o[a - 1], o[a - 4], s.stripFlags(o[a - 4], o[a]), this._$); break; case 24: this.$ = { type: "PartialStatement", name: o[a - 3], params: o[a - 2], hash: o[a - 1], indent: "", strip: s.stripFlags(o[a - 4], o[a]), loc: s.locInfo(this._$) }; break; case 25: this.$ = s.preparePartialBlock(o[a - 2], o[a - 1], o[a], this._$); break; case 26: this.$ = { path: o[a - 3], params: o[a - 2], hash: o[a - 1], strip: s.stripFlags(o[a - 4], o[a]) }; break; case 29: this.$ = { type: "SubExpression", path: o[a - 3], params: o[a - 2], hash: o[a - 1], loc: s.locInfo(this._$) }; break; case 30: this.$ = { type: "Hash", pairs: o[a], loc: s.locInfo(this._$) }; break; case 31: this.$ = { type: "HashPair", key: s.id(o[a - 2]), value: o[a], loc: s.locInfo(this._$) }; break; case 32: this.$ = s.id(o[a - 1]); break; case 35: this.$ = { type: "StringLiteral", value: o[a], original: o[a], loc: s.locInfo(this._$) }; break; case 36: this.$ = { type: "NumberLiteral", value: Number(o[a]), original: Number(o[a]), loc: s.locInfo(this._$) }; break; case 37: this.$ = { type: "BooleanLiteral", value: "true" === o[a], original: "true" === o[a], loc: s.locInfo(this._$) }; break; case 38: this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: s.locInfo(this._$) }; break; case 39: this.$ = { type: "NullLiteral", original: null, value: null, loc: s.locInfo(this._$) }; break; case 42: this.$ = s.preparePath(!0, o[a], this._$); break; case 43: this.$ = s.preparePath(!1, o[a], this._$); break; case 44: o[a - 2].push({ part: s.id(o[a]), original: o[a], separator: o[a - 1] }), this.$ = o[a - 2]; break; case 45: this.$ = [{ part: s.id(o[a]), original: o[a] }]; break; case 46: case 48: case 50: case 58: case 64: case 70: case 78: case 82: case 86: case 90: case 94: this.$ = []; break; case 47: case 49: case 51: case 59: case 65: case 71: case 79: case 83: case 87: case 91: case 95: case 99: case 101: o[a - 1].push(o[a]); break; case 98: case 100: this.$ = [o[a]] } }, table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] }, parseError: function (t, e) { throw new Error(t) }, parse: function (t) { var e = this, i = [0], s = [null], r = [], o = this.table, n = "", a = 0, l = 0; this.lexer.setInput(t), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, void 0 === this.lexer.yylloc && (this.lexer.yylloc = {}); var c = this.lexer.yylloc; r.push(c); var h = this.lexer.options && this.lexer.options.ranges; "function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError); for (var p, u, d, f, m, g, y, v, b, k = {}; ;) { if (u = i[i.length - 1], this.defaultActions[u] ? d = this.defaultActions[u] : (null == p && (b = void 0, "number" != typeof (b = e.lexer.lex() || 1) && (b = e.symbols_[b] || b), p = b), d = o[u] && o[u][p]), void 0 === d || !d.length || !d[0]) { var _ = ""; for (m in v = [], o[u]) this.terminals_[m] && m > 2 && v.push("'" + this.terminals_[m] + "'"); _ = this.lexer.showPosition ? "Parse error on line " + (a + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + v.join(", ") + ", got '" + (this.terminals_[p] || p) + "'" : "Parse error on line " + (a + 1) + ": Unexpected " + (1 == p ? "end of input" : "'" + (this.terminals_[p] || p) + "'"), this.parseError(_, { text: this.lexer.match, token: this.terminals_[p] || p, line: this.lexer.yylineno, loc: c, expected: v }) } if (d[0] instanceof Array && d.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + u + ", token: " + p); switch (d[0]) { case 1: i.push(p), s.push(this.lexer.yytext), r.push(this.lexer.yylloc), i.push(d[1]), p = null, l = this.lexer.yyleng, n = this.lexer.yytext, a = this.lexer.yylineno, c = this.lexer.yylloc; break; case 2: if (g = this.productions_[d[1]][1], k.$ = s[s.length - g], k._$ = { first_line: r[r.length - (g || 1)].first_line, last_line: r[r.length - 1].last_line, first_column: r[r.length - (g || 1)].first_column, last_column: r[r.length - 1].last_column }, h && (k._$.range = [r[r.length - (g || 1)].range[0], r[r.length - 1].range[1]]), void 0 !== (f = this.performAction.call(k, n, l, a, this.yy, d[1], s, r))) return f; g && (i = i.slice(0, -1 * g * 2), s = s.slice(0, -1 * g), r = r.slice(0, -1 * g)), i.push(this.productions_[d[1]][0]), s.push(k.$), r.push(k._$), y = o[i[i.length - 2]][i[i.length - 1]], i.push(y); break; case 3: return !0 } } return !0 } }, e = function () { var t = { EOF: 1, parseError: function (t, e) { if (!this.yy.parser) throw new Error(t); this.yy.parser.parseError(t, e) }, setInput: function (t) { return this._input = t, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this }, input: function () { var t = this._input[0]; return this.yytext += t, this.yyleng++, this.offset++, this.match += t, this.matched += t, t.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t }, unput: function (t) { var e = t.length, i = t.split(/(?:\r\n?|\n)/g); this._input = t + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - e - 1), this.offset -= e; var s = this.match.split(/(?:\r\n?|\n)/g); this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), i.length - 1 && (this.yylineno -= i.length - 1); var r = this.yylloc.range; return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: i ? (i.length === s.length ? this.yylloc.first_column : 0) + s[s.length - i.length].length - i[0].length : this.yylloc.first_column - e }, this.options.ranges && (this.yylloc.range = [r[0], r[0] + this.yyleng - e]), this }, more: function () { return this._more = !0, this }, less: function (t) { this.unput(this.match.slice(t)) }, pastInput: function () { var t = this.matched.substr(0, this.matched.length - this.match.length); return (t.length > 20 ? "..." : "") + t.substr(-20).replace(/\n/g, "") }, upcomingInput: function () { var t = this.match; return t.length < 20 && (t += this._input.substr(0, 20 - t.length)), (t.substr(0, 20) + (t.length > 20 ? "..." : "")).replace(/\n/g, "") }, showPosition: function () { var t = this.pastInput(), e = new Array(t.length + 1).join("-"); return t + this.upcomingInput() + "\n" + e + "^" }, next: function () { if (this.done) return this.EOF; var t, e, i, s, r; this._input || (this.done = !0), this._more || (this.yytext = "", this.match = ""); for (var o = this._currentRules(), n = 0; n < o.length && (!(i = this._input.match(this.rules[o[n]])) || e && !(i[0].length > e[0].length) || (e = i, s = n, this.options.flex)); n++); return e ? ((r = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += r.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: r ? r[r.length - 1].length - r[r.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length }, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], t = this.performAction.call(this, this.yy, this, o[s], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), t || void 0) : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno }) }, lex: function () { var t = this.next(); return void 0 !== t ? t : this.lex() }, begin: function (t) { this.conditionStack.push(t) }, popState: function () { return this.conditionStack.pop() }, _currentRules: function () { return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules }, topState: function () { return this.conditionStack[this.conditionStack.length - 2] }, pushState: function (t) { this.begin(t) }, options: {}, performAction: function (t, e, i, s) { function r(t, i) { return e.yytext = e.yytext.substring(t, e.yyleng - i + t) } switch (i) { case 0: if ("\\\\" === e.yytext.slice(-2) ? (r(0, 1), this.begin("mu")) : "\\" === e.yytext.slice(-1) ? (r(0, 1), this.begin("emu")) : this.begin("mu"), e.yytext) return 15; break; case 1: case 5: return 15; case 2: return this.popState(), 15; case 3: return this.begin("raw"), 15; case 4: return this.popState(), "raw" === this.conditionStack[this.conditionStack.length - 1] ? 15 : (r(5, 9), "END_RAW_BLOCK"); case 6: case 22: return this.popState(), 14; case 7: return 65; case 8: return 68; case 9: return 19; case 10: return this.popState(), this.begin("raw"), 23; case 11: return 55; case 12: return 60; case 13: return 29; case 14: return 47; case 15: case 16: return this.popState(), 44; case 17: return 34; case 18: return 39; case 19: return 51; case 20: case 23: return 48; case 21: this.unput(e.yytext), this.popState(), this.begin("com"); break; case 24: return 73; case 25: case 26: case 41: return 72; case 27: return 87; case 28: break; case 29: return this.popState(), 54; case 30: return this.popState(), 33; case 31: return e.yytext = r(1, 2).replace(/\\"/g, '"'), 80; case 32: return e.yytext = r(1, 2).replace(/\\'/g, "'"), 80; case 33: return 85; case 34: case 35: return 82; case 36: return 83; case 37: return 84; case 38: return 81; case 39: return 75; case 40: return 77; case 42: return e.yytext = e.yytext.replace(/\\([\\\]])/g, "$1"), 72; case 43: return "INVALID"; case 44: return 5 } }, rules: [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], conditions: { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: !1 }, emu: { rules: [2], inclusive: !1 }, com: { rules: [6], inclusive: !1 }, raw: { rules: [3, 4, 5], inclusive: !1 }, INITIAL: { rules: [0, 1, 44], inclusive: !0 } } }; return t }(); function i() { this.yy = {} } return t.lexer = e, i.prototype = t, t.Parser = i, new i }(); function Te() { this.parents = [] } function Ue(t) { this.acceptRequired(t, "path"), this.acceptArray(t.params), this.acceptKey(t, "hash") } function ze(t) { Ue.call(this, t), this.acceptKey(t, "program"), this.acceptKey(t, "inverse") } function Ve(t) { this.acceptRequired(t, "name"), this.acceptArray(t.params), this.acceptKey(t, "hash") } function Fe(t = {}) { this.options = t } function qe(t, e, i) { void 0 === e && (e = t.length); let s = t[e - 1], r = t[e - 2]; return s ? "ContentStatement" === s.type ? (r || !i ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(s.original) : void 0 : i } function Ke(t, e, i) { void 0 === e && (e = -1); let s = t[e + 1], r = t[e + 2]; return s ? "ContentStatement" === s.type ? (r || !i ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(s.original) : void 0 : i } function Ge(t, e, i) { let s = t[null == e ? 0 : e + 1]; if (!s || "ContentStatement" !== s.type || !i && s.rightStripped) return; let r = s.value; s.value = s.value.replace(i ? /^\s+/ : /^[ \t]*\r?\n?/, ""), s.rightStripped = s.value !== r } function Ze(t, e, i) { let s = t[null == e ? t.length - 1 : e - 1]; if (!s || "ContentStatement" !== s.type || !i && s.leftStripped) return; let r = s.value; return s.value = s.value.replace(i ? /\s+$/ : /[ \t]+$/, ""), s.leftStripped = s.value !== r, s.leftStripped } function We(t, e) { if (e = e.path ? e.path.original : e, t.path.original !== e) { let i = { loc: t.path.loc }; throw new ye(t.path.original + " doesn't match " + e, i) } } Te.prototype = { constructor: Te, mutating: !1, acceptKey: function (t, e) { let i = this.accept(t[e]); if (this.mutating) { if (i && !Te.prototype[i.type]) throw new ye('Unexpected node type "' + i.type + '" found when accepting ' + e + " on " + t.type); t[e] = i } }, acceptRequired: function (t, e) { if (this.acceptKey(t, e), !t[e]) throw new ye(t.type + " requires " + e) }, acceptArray: function (t) { for (let e = 0, i = t.length; e < i; e++)this.acceptKey(t, e), t[e] || (t.splice(e, 1), e--, i--) }, accept: function (t) { if (!t) return; if (!this[t.type]) throw new ye("Unknown type: " + t.type, t); this.current && this.parents.unshift(this.current), this.current = t; let e = this[t.type](t); return this.current = this.parents.shift(), !this.mutating || e ? e : !1 !== e ? t : void 0 }, Program: function (t) { this.acceptArray(t.body) }, MustacheStatement: Ue, Decorator: Ue, BlockStatement: ze, DecoratorBlock: ze, PartialStatement: Ve, PartialBlockStatement: function (t) { Ve.call(this, t), this.acceptKey(t, "program") }, ContentStatement: function () { }, CommentStatement: function () { }, SubExpression: Ue, PathExpression: function () { }, StringLiteral: function () { }, NumberLiteral: function () { }, BooleanLiteral: function () { }, UndefinedLiteral: function () { }, NullLiteral: function () { }, Hash: function (t) { this.acceptArray(t.pairs) }, HashPair: function (t) { this.acceptRequired(t, "value") } }, Fe.prototype = new Te, Fe.prototype.Program = function (t) { const e = !this.options.ignoreStandalone; let i = !this.isRootSeen; this.isRootSeen = !0; let s = t.body; for (let t = 0, r = s.length; t < r; t++) { let r = s[t], o = this.accept(r); if (!o) continue; let n = qe(s, t, i), a = Ke(s, t, i), l = o.openStandalone && n, c = o.closeStandalone && a, h = o.inlineStandalone && n && a; o.close && Ge(s, t, !0), o.open && Ze(s, t, !0), e && h && (Ge(s, t), Ze(s, t) && "PartialStatement" === r.type && (r.indent = /([ \t]+$)/.exec(s[t - 1].original)[1])), e && l && (Ge((r.program || r.inverse).body), Ze(s, t)), e && c && (Ge(s, t), Ze((r.inverse || r.program).body)) } return t }, Fe.prototype.BlockStatement = Fe.prototype.DecoratorBlock = Fe.prototype.PartialBlockStatement = function (t) { this.accept(t.program), this.accept(t.inverse); let e = t.program || t.inverse, i = t.program && t.inverse, s = i, r = i; if (i && i.chained) for (s = i.body[0].program; r.chained;)r = r.body[r.body.length - 1].program; let o = { open: t.openStrip.open, close: t.closeStrip.close, openStandalone: Ke(e.body), closeStandalone: qe((s || e).body) }; if (t.openStrip.close && Ge(e.body, null, !0), i) { let i = t.inverseStrip; i.open && Ze(e.body, null, !0), i.close && Ge(s.body, null, !0), t.closeStrip.open && Ze(r.body, null, !0), !this.options.ignoreStandalone && qe(e.body) && Ke(s.body) && (Ze(e.body), Ge(s.body)) } else t.closeStrip.open && Ze(e.body, null, !0); return o }, Fe.prototype.Decorator = Fe.prototype.MustacheStatement = function (t) { return t.strip }, Fe.prototype.PartialStatement = Fe.prototype.CommentStatement = function (t) { let e = t.strip || {}; return { inlineStandalone: !0, open: e.open, close: e.close } }; var Je = Object.freeze({ __proto__: null, SourceLocation: function (t, e) { this.source = t, this.start = { line: e.first_line, column: e.first_column }, this.end = { line: e.last_line, column: e.last_column } }, id: function (t) { return /^\[.*\]$/.test(t) ? t.substring(1, t.length - 1) : t }, stripFlags: function (t, e) { return { open: "~" === t.charAt(2), close: "~" === e.charAt(e.length - 3) } }, stripComment: function (t) { return t.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "") }, preparePath: function (t, e, i) { i = this.locInfo(i); let s = t ? "@" : "", r = [], o = 0; for (let t = 0, n = e.length; t < n; t++) { let n = e[t].part, a = e[t].original !== n; if (s += (e[t].separator || "") + n, a || ".." !== n && "." !== n && "this" !== n) r.push(n); else { if (r.length > 0) throw new ye("Invalid path: " + s, { loc: i }); ".." === n && o++ } } return { type: "PathExpression", data: t, depth: o, parts: r, original: s, loc: i } }, prepareMustache: function (t, e, i, s, r, o) { let n = s.charAt(3) || s.charAt(2), a = "{" !== n && "&" !== n; return { type: /\*/.test(s) ? "Decorator" : "MustacheStatement", path: t, params: e, hash: i, escaped: a, strip: r, loc: this.locInfo(o) } }, prepareRawBlock: function (t, e, i, s) { We(t, i); let r = { type: "Program", body: e, strip: {}, loc: s = this.locInfo(s) }; return { type: "BlockStatement", path: t.path, params: t.params, hash: t.hash, program: r, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: s } }, prepareBlock: function (t, e, i, s, r, o) { s && s.path && We(t, s); let n, a, l = /\*/.test(t.open); if (e.blockParams = t.blockParams, i) { if (l) throw new ye("Unexpected inverse block on decorator", i); i.chain && (i.program.body[0].closeStrip = s.strip), a = i.strip, n = i.program } return r && (r = n, n = e, e = r), { type: l ? "DecoratorBlock" : "BlockStatement", path: t.path, params: t.params, hash: t.hash, program: e, inverse: n, openStrip: t.strip, inverseStrip: a, closeStrip: s && s.strip, loc: this.locInfo(o) } }, prepareProgram: function (t, e) { if (!e && t.length) { const i = t[0].loc, s = t[t.length - 1].loc; i && s && (e = { source: i.source, start: { line: i.start.line, column: i.start.column }, end: { line: s.end.line, column: s.end.column } }) } return { type: "Program", body: t, strip: {}, loc: e } }, preparePartialBlock: function (t, e, i, s) { return We(t, i), { type: "PartialBlockStatement", name: t.path, params: t.params, hash: t.hash, program: e, openStrip: t.strip, closeStrip: i && i.strip, loc: this.locInfo(s) } } }); let Ye = {}; function Xe(t, e) { if ("Program" === t.type) return t; return He.yy = Ye, Ye.locInfo = function (t) { return new Ye.SourceLocation(e && e.srcName, t) }, He.parse(t) } function Qe(t, e) { let i = Xe(t, e); return new Fe(e).accept(i) } oe(Ye, Je); const ti = [].slice; function ei() { } function ii(t, e) { if (t === e) return !0; if (le(t) && le(e) && t.length === e.length) { for (let i = 0; i < t.length; i++)if (!ii(t[i], e[i])) return !1; return !0 } } function si(t) { if (!t.path.parts) { let e = t.path; t.path = { type: "PathExpression", data: !1, depth: 0, parts: [e.original + ""], original: e.original + "", loc: e.loc } } } let ri; ei.prototype = { compiler: ei, equals: function (t) { let e = this.opcodes.length; if (t.opcodes.length !== e) return !1; for (let i = 0; i < e; i++) { let e = this.opcodes[i], s = t.opcodes[i]; if (e.opcode !== s.opcode || !ii(e.args, s.args)) return !1 } e = this.children.length; for (let i = 0; i < e; i++)if (!this.children[i].equals(t.children[i])) return !1; return !0 }, guid: 0, compile: function (t, e) { return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = e, this.stringParams = e.stringParams, this.trackIds = e.trackIds, e.blockParams = e.blockParams || [], e.knownHelpers = oe(Object.create(null), { helperMissing: !0, blockHelperMissing: !0, each: !0, if: !0, unless: !0, with: !0, log: !0, lookup: !0 }, e.knownHelpers), this.accept(t) }, compileProgram: function (t) { let e = (new this.compiler).compile(t, this.options), i = this.guid++; return this.usePartial = this.usePartial || e.usePartial, this.children[i] = e, this.useDepths = this.useDepths || e.useDepths, i }, accept: function (t) { if (!this[t.type]) throw new ye("Unknown type: " + t.type, t); this.sourceNode.unshift(t); let e = this[t.type](t); return this.sourceNode.shift(), e }, Program: function (t) { this.options.blockParams.unshift(t.blockParams); let e = t.body, i = e.length; for (let t = 0; t < i; t++)this.accept(e[t]); return this.options.blockParams.shift(), this.isSimple = 1 === i, this.blockParams = t.blockParams ? t.blockParams.length : 0, this }, BlockStatement: function (t) { si(t); let e = t.program, i = t.inverse; e = e && this.compileProgram(e), i = i && this.compileProgram(i); let s = this.classifySexpr(t); "helper" === s ? this.helperSexpr(t, e, i) : "simple" === s ? (this.simpleSexpr(t), this.opcode("pushProgram", e), this.opcode("pushProgram", i), this.opcode("emptyHash"), this.opcode("blockValue", t.path.original)) : (this.ambiguousSexpr(t, e, i), this.opcode("pushProgram", e), this.opcode("pushProgram", i), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append") }, DecoratorBlock(t) { let e = t.program && this.compileProgram(t.program), i = this.setupFullMustacheParams(t, e, void 0), s = t.path; this.useDecorators = !0, this.opcode("registerDecorator", i.length, s.original) }, PartialStatement: function (t) { this.usePartial = !0; let e = t.program; e && (e = this.compileProgram(t.program)); let i = t.params; if (i.length > 1) throw new ye("Unsupported number of partial arguments: " + i.length, t); i.length || (this.options.explicitPartialContext ? this.opcode("pushLiteral", "undefined") : i.push({ type: "PathExpression", parts: [], depth: 0 })); let s = t.name.original, r = "SubExpression" === t.name.type; r && this.accept(t.name), this.setupFullMustacheParams(t, e, void 0, !0); let o = t.indent || ""; this.options.preventIndent && o && (this.opcode("appendContent", o), o = ""), this.opcode("invokePartial", r, s, o), this.opcode("append") }, PartialBlockStatement: function (t) { this.PartialStatement(t) }, MustacheStatement: function (t) { this.SubExpression(t), t.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append") }, Decorator(t) { this.DecoratorBlock(t) }, ContentStatement: function (t) { t.value && this.opcode("appendContent", t.value) }, CommentStatement: function () { }, SubExpression: function (t) { si(t); let e = this.classifySexpr(t); "simple" === e ? this.simpleSexpr(t) : "helper" === e ? this.helperSexpr(t) : this.ambiguousSexpr(t) }, ambiguousSexpr: function (t, e, i) { let s = t.path, r = s.parts[0], o = null != e || null != i; this.opcode("getContext", s.depth), this.opcode("pushProgram", e), this.opcode("pushProgram", i), s.strict = !0, this.accept(s), this.opcode("invokeAmbiguous", r, o) }, simpleSexpr: function (t) { let e = t.path; e.strict = !0, this.accept(e), this.opcode("resolvePossibleLambda") }, helperSexpr: function (t, e, i) { let s = this.setupFullMustacheParams(t, e, i), r = t.path, o = r.parts[0]; if (this.options.knownHelpers[o]) this.opcode("invokeKnownHelper", s.length, o); else { if (this.options.knownHelpersOnly) throw new ye("You specified knownHelpersOnly, but used the unknown helper " + o, t); r.strict = !0, r.falsy = !0, this.accept(r), this.opcode("invokeHelper", s.length, r.original, je.helpers.simpleId(r)) } }, PathExpression: function (t) { this.addDepth(t.depth), this.opcode("getContext", t.depth); let e = t.parts[0], i = je.helpers.scopedId(t), s = !t.depth && !i && this.blockParamIndex(e); s ? this.opcode("lookupBlockParam", s, t.parts) : e ? t.data ? (this.options.data = !0, this.opcode("lookupData", t.depth, t.parts, t.strict)) : this.opcode("lookupOnContext", t.parts, t.falsy, t.strict, i) : this.opcode("pushContext") }, StringLiteral: function (t) { this.opcode("pushString", t.value) }, NumberLiteral: function (t) { this.opcode("pushLiteral", t.value) }, BooleanLiteral: function (t) { this.opcode("pushLiteral", t.value) }, UndefinedLiteral: function () { this.opcode("pushLiteral", "undefined") }, NullLiteral: function () { this.opcode("pushLiteral", "null") }, Hash: function (t) { let e = t.pairs, i = 0, s = e.length; for (this.opcode("pushHash"); i < s; i++)this.pushParam(e[i].value); for (; i--;)this.opcode("assignToHash", e[i].key); this.opcode("popHash") }, opcode: function (t) { this.opcodes.push({ opcode: t, args: ti.call(arguments, 1), loc: this.sourceNode[0].loc }) }, addDepth: function (t) { t && (this.useDepths = !0) }, classifySexpr: function (t) { let e = je.helpers.simpleId(t.path), i = e && !!this.blockParamIndex(t.path.parts[0]), s = !i && je.helpers.helperExpression(t), r = !i && (s || e); if (r && !s) { let e = t.path.parts[0], i = this.options; i.knownHelpers[e] ? s = !0 : i.knownHelpersOnly && (r = !1) } return s ? "helper" : r ? "ambiguous" : "simple" }, pushParams: function (t) { for (let e = 0, i = t.length; e < i; e++)this.pushParam(t[e]) }, pushParam: function (t) { let e = null != t.value ? t.value : t.original || ""; if (this.stringParams) e.replace && (e = e.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")), t.depth && this.addDepth(t.depth), this.opcode("getContext", t.depth || 0), this.opcode("pushStringParam", e, t.type), "SubExpression" === t.type && this.accept(t); else { if (this.trackIds) { let i; if (!t.parts || je.helpers.scopedId(t) || t.depth || (i = this.blockParamIndex(t.parts[0])), i) { let e = t.parts.slice(1).join("."); this.opcode("pushId", "BlockParam", i, e) } else e = t.original || e, e.replace && (e = e.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "")), this.opcode("pushId", t.type, e) } this.accept(t) } }, setupFullMustacheParams: function (t, e, i, s) { let r = t.params; return this.pushParams(r), this.opcode("pushProgram", e), this.opcode("pushProgram", i), t.hash ? this.accept(t.hash) : this.opcode("emptyHash", s), r }, blockParamIndex: function (t) { for (let e = 0, i = this.options.blockParams.length; e < i; e++) { let i = this.options.blockParams[e], s = i && ce(i, t); if (i && s >= 0) return [e, s] } } }; try { if ("function" != typeof define || !define.amd) { let t = require("source-map"); ri = t.SourceNode } } catch (t) { } function oi(t, e, i) { if (le(t)) { let s = []; for (let r = 0, o = t.length; r < o; r++)s.push(e.wrap(t[r], i)); return s } return "boolean" == typeof t || "number" == typeof t ? t + "" : t } function ni(t) { this.srcFile = t, this.source = [] } function ai(t) { this.value = t } function li() { } ri || (ri = function (t, e, i, s) { this.src = "", s && this.add(s) }, ri.prototype = { add: function (t) { le(t) && (t = t.join("")), this.src += t }, prepend: function (t) { le(t) && (t = t.join("")), this.src = t + this.src }, toStringWithSourceMap: function () { return { code: this.toString() } }, toString: function () { return this.src } }), ni.prototype = { isEmpty() { return !this.source.length }, prepend: function (t, e) { this.source.unshift(this.wrap(t, e)) }, push: function (t, e) { this.source.push(this.wrap(t, e)) }, merge: function () { let t = this.empty(); return this.each((function (e) { t.add(["  ", e, "\n"]) })), t }, each: function (t) { for (let e = 0, i = this.source.length; e < i; e++)t(this.source[e]) }, empty: function () { let t = this.currentLocation || { start: {} }; return new ri(t.start.line, t.start.column, this.srcFile) }, wrap: function (t, e = this.currentLocation || { start: {} }) { return t instanceof ri ? t : (t = oi(t, this, e), new ri(e.start.line, e.start.column, this.srcFile, t)) }, functionCall: function (t, e, i) { return i = this.generateList(i), this.wrap([t, e ? "." + e + "(" : "(", i, ")"]) }, quotedString: function (t) { return '"' + (t + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"' }, objectLiteral: function (t) { let e = []; Object.keys(t).forEach((i => { let s = oi(t[i], this); "undefined" !== s && e.push([this.quotedString(i), ":", s]) })); let i = this.generateList(e); return i.prepend("{"), i.add("}"), i }, generateList: function (t) { let e = this.empty(); for (let i = 0, s = t.length; i < s; i++)i && e.add(","), e.add(oi(t[i], this)); return e }, generateArray: function (t) { let e = this.generateList(t); return e.prepend("["), e.add("]"), e } }, li.prototype = { nameLookup: function (t, e) { return this.internalNameLookup(t, e) }, depthedLookup: function (t) { return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(t), ")"] }, compilerInfo: function () { return [8, xe[8]] }, appendToBuffer: function (t, e, i) { return le(t) || (t = [t]), t = this.source.wrap(t, e), this.environment.isSimple ? ["return ", t, ";"] : i ? ["buffer += ", t, ";"] : (t.appendToBuffer = !0, t) }, initializeBuffer: function () { return this.quotedString("") }, internalNameLookup: function (t, e) { return this.lookupPropertyFunctionIsUsed = !0, ["lookupProperty(", t, ",", JSON.stringify(e), ")"] }, lookupPropertyFunctionIsUsed: !1, compile: function (t, e, i, s) { this.environment = t, this.options = e, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !s, this.name = this.environment.name, this.isChild = !!i, this.context = i || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(t, e), this.useDepths = this.useDepths || t.useDepths || t.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || t.useBlockParams; let r, o, n, a, l = t.opcodes; for (n = 0, a = l.length; n < a; n++)r = l[n], this.source.currentLocation = r.loc, o = o || r.loc, this[r.opcode].apply(this, r.args); if (this.source.currentLocation = o, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new ye("Compile completed with content left on stack"); this.decorators.isEmpty() ? this.decorators = void 0 : (this.useDecorators = !0, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]), this.decorators.push("return fn;"), s ? this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]) : (this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n"), this.decorators.push("}\n"), this.decorators = this.decorators.merge())); let c = this.createFunctionContext(s); if (this.isChild) return c; { let t = { compiler: this.compilerInfo(), main: c }; this.decorators && (t.main_d = this.decorators, t.useDecorators = !0); let { programs: i, decorators: r } = this.context; for (n = 0, a = i.length; n < a; n++)i[n] && (t[n] = i[n], r[n] && (t[n + "_d"] = r[n], t.useDecorators = !0)); return this.environment.usePartial && (t.usePartial = !0), this.options.data && (t.useData = !0), this.useDepths && (t.useDepths = !0), this.useBlockParams && (t.useBlockParams = !0), this.options.compat && (t.compat = !0), s ? t.compilerOptions = this.options : (t.compiler = JSON.stringify(t.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, t = this.objectLiteral(t), e.srcName ? (t = t.toStringWithSourceMap({ file: e.destName }), t.map = t.map && t.map.toString()) : t = t.toString()), t } }, preamble: function () { this.lastContext = 0, this.source = new ni(this.options.srcName), this.decorators = new ni(this.options.srcName) }, createFunctionContext: function (t) { let e = "", i = this.stackVars.concat(this.registers.list); i.length > 0 && (e += ", " + i.join(", ")); let s = 0; Object.keys(this.aliases).forEach((t => { let i = this.aliases[t]; i.children && i.referenceCount > 1 && (e += ", alias" + ++s + "=" + t, i.children[0] = "alias" + s) })), this.lookupPropertyFunctionIsUsed && (e += ", " + this.lookupPropertyFunctionVarDeclaration()); let r = ["container", "depth0", "helpers", "partials", "data"]; (this.useBlockParams || this.useDepths) && r.push("blockParams"), this.useDepths && r.push("depths"); let o = this.mergeSource(e); return t ? (r.push(o), Function.apply(this, r)) : this.source.wrap(["function(", r.join(","), ") {\n  ", o, "}"]) }, mergeSource: function (t) { let e, i, s, r, o = this.environment.isSimple, n = !this.forceBuffer; return this.source.each((t => { t.appendToBuffer ? (s ? t.prepend("  + ") : s = t, r = t) : (s && (i ? s.prepend("buffer += ") : e = !0, r.add(";"), s = r = void 0), i = !0, o || (n = !1)) })), n ? s ? (s.prepend("return "), r.add(";")) : i || this.source.push('return "";') : (t += ", buffer = " + (e ? "" : this.initializeBuffer()), s ? (s.prepend("return buffer + "), r.add(";")) : this.source.push("return buffer;")), t && this.source.prepend("var " + t.substring(2) + (e ? "" : ";\n")), this.source.merge() }, lookupPropertyFunctionVarDeclaration: function () { return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim() }, blockValue: function (t) { let e = this.aliasable("container.hooks.blockHelperMissing"), i = [this.contextName(0)]; this.setupHelperArgs(t, 0, i); let s = this.popStack(); i.splice(1, 0, s), this.push(this.source.functionCall(e, "call", i)) }, ambiguousBlockValue: function () { let t = this.aliasable("container.hooks.blockHelperMissing"), e = [this.contextName(0)]; this.setupHelperArgs("", 0, e, !0), this.flushInline(); let i = this.topStack(); e.splice(1, 0, i), this.pushSource(["if (!", this.lastHelper, ") { ", i, " = ", this.source.functionCall(t, "call", e), "}"]) }, appendContent: function (t) { this.pendingContent ? t = this.pendingContent + t : this.pendingLocation = this.source.currentLocation, this.pendingContent = t }, append: function () { if (this.isInline()) this.replaceStack((t => [" != null ? ", t, ' : ""'])), this.pushSource(this.appendToBuffer(this.popStack())); else { let t = this.popStack(); this.pushSource(["if (", t, " != null) { ", this.appendToBuffer(t, void 0, !0), " }"]), this.environment.isSimple && this.pushSource(["else { ", this.appendToBuffer("''", void 0, !0), " }"]) } }, appendEscaped: function () { this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"])) }, getContext: function (t) { this.lastContext = t }, pushContext: function () { this.pushStackLiteral(this.contextName(this.lastContext)) }, lookupOnContext: function (t, e, i, s) { let r = 0; s || !this.options.compat || this.lastContext ? this.pushContext() : this.push(this.depthedLookup(t[r++])), this.resolvePath("context", t, r, e, i) }, lookupBlockParam: function (t, e) { this.useBlockParams = !0, this.push(["blockParams[", t[0], "][", t[1], "]"]), this.resolvePath("context", e, 1) }, lookupData: function (t, e, i) { t ? this.pushStackLiteral("container.data(data, " + t + ")") : this.pushStackLiteral("data"), this.resolvePath("data", e, 0, !0, i) }, resolvePath: function (t, e, i, s, r) { if (this.options.strict || this.options.assumeObjects) return void this.push(function (t, e, i, s) { let r = e.popStack(), o = 0, n = i.length; t && n--; for (; o < n; o++)r = e.nameLookup(r, i[o], s); return t ? [e.aliasable("container.strict"), "(", r, ", ", e.quotedString(i[o]), ", ", JSON.stringify(e.source.currentLocation), " )"] : r }(this.options.strict && r, this, e, t)); let o = e.length; for (; i < o; i++)this.replaceStack((r => { let o = this.nameLookup(r, e[i], t); return s ? [" && ", o] : [" != null ? ", o, " : ", r] })) }, resolvePossibleLambda: function () { this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]) }, pushStringParam: function (t, e) { this.pushContext(), this.pushString(e), "SubExpression" !== e && ("string" == typeof t ? this.pushString(t) : this.pushStackLiteral(t)) }, emptyHash: function (t) { this.trackIds && this.push("{}"), this.stringParams && (this.push("{}"), this.push("{}")), this.pushStackLiteral(t ? "undefined" : "{}") }, pushHash: function () { this.hash && this.hashes.push(this.hash), this.hash = { values: {}, types: [], contexts: [], ids: [] } }, popHash: function () { let t = this.hash; this.hash = this.hashes.pop(), this.trackIds && this.push(this.objectLiteral(t.ids)), this.stringParams && (this.push(this.objectLiteral(t.contexts)), this.push(this.objectLiteral(t.types))), this.push(this.objectLiteral(t.values)) }, pushString: function (t) { this.pushStackLiteral(this.quotedString(t)) }, pushLiteral: function (t) { this.pushStackLiteral(t) }, pushProgram: function (t) { null != t ? this.pushStackLiteral(this.programExpression(t)) : this.pushStackLiteral(null) }, registerDecorator(t, e) { let i = this.nameLookup("decorators", e, "decorator"), s = this.setupHelperArgs(e, t); this.decorators.push(["fn = ", this.decorators.functionCall(i, "", ["fn", "props", "container", s]), " || fn;"]) }, invokeHelper: function (t, e, i) { let s = this.popStack(), r = this.setupHelper(t, e), o = []; i && o.push(r.name), o.push(s), this.options.strict || o.push(this.aliasable("container.hooks.helperMissing")); let n = ["(", this.itemsSeparatedBy(o, "||"), ")"], a = this.source.functionCall(n, "call", r.callParams); this.push(a) }, itemsSeparatedBy: function (t, e) { let i = []; i.push(t[0]); for (let s = 1; s < t.length; s++)i.push(e, t[s]); return i }, invokeKnownHelper: function (t, e) { let i = this.setupHelper(t, e); this.push(this.source.functionCall(i.name, "call", i.callParams)) }, invokeAmbiguous: function (t, e) { this.useRegister("helper"); let i = this.popStack(); this.emptyHash(); let s = this.setupHelper(0, t, e), r = ["(", "(helper = ", this.lastHelper = this.nameLookup("helpers", t, "helper"), " || ", i, ")"]; this.options.strict || (r[0] = "(helper = ", r.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"))), this.push(["(", r, s.paramsInit ? ["),(", s.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", s.callParams), " : helper))"]) }, invokePartial: function (t, e, i) { let s = [], r = this.setupParams(e, 1, s); t && (e = this.popStack(), delete r.name), i && (r.indent = JSON.stringify(i)), r.helpers = "helpers", r.partials = "partials", r.decorators = "container.decorators", t ? s.unshift(e) : s.unshift(this.nameLookup("partials", e, "partial")), this.options.compat && (r.depths = "depths"), r = this.objectLiteral(r), s.push(r), this.push(this.source.functionCall("container.invokePartial", "", s)) }, assignToHash: function (t) { let e, i, s, r = this.popStack(); this.trackIds && (s = this.popStack()), this.stringParams && (i = this.popStack(), e = this.popStack()); let o = this.hash; e && (o.contexts[t] = e), i && (o.types[t] = i), s && (o.ids[t] = s), o.values[t] = r }, pushId: function (t, e, i) { "BlockParam" === t ? this.pushStackLiteral("blockParams[" + e[0] + "].path[" + e[1] + "]" + (i ? " + " + JSON.stringify("." + i) : "")) : "PathExpression" === t ? this.pushString(e) : "SubExpression" === t ? this.pushStackLiteral("true") : this.pushStackLiteral("null") }, compiler: li, compileChildren: function (t, e) { let i, s, r = t.children; for (let t = 0, o = r.length; t < o; t++) { i = r[t], s = new this.compiler; let o = this.matchExistingProgram(i); if (null == o) { this.context.programs.push(""); let t = this.context.programs.length; i.index = t, i.name = "program" + t, this.context.programs[t] = s.compile(i, e, this.context, !this.precompile), this.context.decorators[t] = s.decorators, this.context.environments[t] = i, this.useDepths = this.useDepths || s.useDepths, this.useBlockParams = this.useBlockParams || s.useBlockParams, i.useDepths = this.useDepths, i.useBlockParams = this.useBlockParams } else i.index = o.index, i.name = "program" + o.index, this.useDepths = this.useDepths || o.useDepths, this.useBlockParams = this.useBlockParams || o.useBlockParams } }, matchExistingProgram: function (t) { for (let e = 0, i = this.context.environments.length; e < i; e++) { let i = this.context.environments[e]; if (i && i.equals(t)) return i } }, programExpression: function (t) { let e = this.environment.children[t], i = [e.index, "data", e.blockParams]; return (this.useBlockParams || this.useDepths) && i.push("blockParams"), this.useDepths && i.push("depths"), "container.program(" + i.join(", ") + ")" }, useRegister: function (t) { this.registers[t] || (this.registers[t] = !0, this.registers.list.push(t)) }, push: function (t) { return t instanceof ai || (t = this.source.wrap(t)), this.inlineStack.push(t), t }, pushStackLiteral: function (t) { this.push(new ai(t)) }, pushSource: function (t) { this.pendingContent && (this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0), t && this.source.push(t) }, replaceStack: function (t) { let e, i, s, r = ["("]; if (!this.isInline()) throw new ye("replaceStack on non-inline"); let o = this.popStack(!0); if (o instanceof ai) e = [o.value], r = ["(", e], s = !0; else { i = !0; let t = this.incrStack(); r = ["((", this.push(t), " = ", o, ")"], e = this.topStack() } let n = t.call(this, e); s || this.popStack(), i && this.stackSlot--, this.push(r.concat(n, ")")) }, incrStack: function () { return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName() }, topStackName: function () { return "stack" + this.stackSlot }, flushInline: function () { let t = this.inlineStack; this.inlineStack = []; for (let e = 0, i = t.length; e < i; e++) { let i = t[e]; if (i instanceof ai) this.compileStack.push(i); else { let t = this.incrStack(); this.pushSource([t, " = ", i, ";"]), this.compileStack.push(t) } } }, isInline: function () { return this.inlineStack.length }, popStack: function (t) { let e = this.isInline(), i = (e ? this.inlineStack : this.compileStack).pop(); if (!t && i instanceof ai) return i.value; if (!e) { if (!this.stackSlot) throw new ye("Invalid stack pop"); this.stackSlot-- } return i }, topStack: function () { let t = this.isInline() ? this.inlineStack : this.compileStack, e = t[t.length - 1]; return e instanceof ai ? e.value : e }, contextName: function (t) { return this.useDepths && t ? "depths[" + t + "]" : "depth" + t }, quotedString: function (t) { return this.source.quotedString(t) }, objectLiteral: function (t) { return this.source.objectLiteral(t) }, aliasable: function (t) { let e = this.aliases[t]; return e ? (e.referenceCount++, e) : (e = this.aliases[t] = this.source.wrap(t), e.aliasable = !0, e.referenceCount = 1, e) }, setupHelper: function (t, e, i) { let s = []; return { params: s, paramsInit: this.setupHelperArgs(e, t, s, i), name: this.nameLookup("helpers", e, "helper"), callParams: [this.aliasable(`${this.contextName(0)} != null ? ${this.contextName(0)} : (container.nullContext || {})`)].concat(s) } }, setupParams: function (t, e, i) { let s, r = {}, o = [], n = [], a = [], l = !i; l && (i = []), r.name = this.quotedString(t), r.hash = this.popStack(), this.trackIds && (r.hashIds = this.popStack()), this.stringParams && (r.hashTypes = this.popStack(), r.hashContexts = this.popStack()); let c = this.popStack(), h = this.popStack(); (h || c) && (r.fn = h || "container.noop", r.inverse = c || "container.noop"); let p = e; for (; p--;)s = this.popStack(), i[p] = s, this.trackIds && (a[p] = this.popStack()), this.stringParams && (n[p] = this.popStack(), o[p] = this.popStack()); return l && (r.args = this.source.generateArray(i)), this.trackIds && (r.ids = this.source.generateArray(a)), this.stringParams && (r.types = this.source.generateArray(n), r.contexts = this.source.generateArray(o)), this.options.data && (r.data = "data"), this.useBlockParams && (r.blockParams = "blockParams"), r }, setupHelperArgs: function (t, e, i, s) { let r = this.setupParams(t, e, i); return r.loc = JSON.stringify(this.source.currentLocation), r = this.objectLiteral(r), s ? (this.useRegister("options"), i.push("options"), ["options=", r]) : i ? (i.push(r), "") : r } }, function () { const t = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), e = li.RESERVED_WORDS = {}; for (let i = 0, s = t.length; i < s; i++)e[t[i]] = !0 }(), li.isValidJavaScriptVariableName = function (t) { return !li.RESERVED_WORDS[t] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(t) }; let ci = Be.create; function hi() { let t = ci(); return t.compile = function (e, i) { return function (t, e = {}, i) { if (null == t || "string" != typeof t && "Program" !== t.type) throw new ye("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + t); let s; function r() { let s = i.parse(t, e), r = (new i.Compiler).compile(s, e), o = (new i.JavaScriptCompiler).compile(r, e, void 0, !0); return i.template(o) } function o(t, e) { return s || (s = r()), s.call(this, t, e) } return "data" in (e = oe({}, e)) || (e.data = !0), e.compat && (e.useDepths = !0), o._setup = function (t) { return s || (s = r()), s._setup(t) }, o._child = function (t, e, i, o) { return s || (s = r()), s._child(t, e, i, o) }, o }(e, i, t) }, t.precompile = function (e, i) { return function (t, e, i) { if (null == t || "string" != typeof t && "Program" !== t.type) throw new ye("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + t); "data" in (e = e || {}) || (e.data = !0), e.compat && (e.useDepths = !0); let s = i.parse(t, e), r = (new i.Compiler).compile(s, e); return (new i.JavaScriptCompiler).compile(r, e) }(e, i, t) }, t.AST = je, t.Compiler = ei, t.JavaScriptCompiler = li, t.Parser = He, t.parse = Qe, t.parseWithoutProcessing = Xe, t } let pi = hi(); pi.create = hi, Me(pi), pi.Visitor = Te, pi.default = pi; var ui = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; const di = t => { class e extends t { constructor() { super(...arguments), this.hasCustomTemplate = !1 } connectedCallback() { super.connectedCallback(), this.compileTemplate() } render() { return this.compiledTemplate ? te(this.compiledTemplate(this.getTemplateContext())) : this.renderDefault() } compileTemplate() { const t = this.getTemplateContent(); this.hasCustomTemplate = !!t, t && (this.compiledTemplate = pi.compile(t)) } getTemplateContent() { return this.querySelector("template[slot]")?.innerHTML || this.template } } return ui([tt({ type: String })], e.prototype, "template", void 0), e }; var fi = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let mi = class extends (di(ht)) { constructor() { super(...arguments), this.fields = ["name", "formatted_address", "formatted_phone_number", "price_level", "rating", "types", "user_ratings_total", "vicinity"], this.placesController = new Xt(this) } static { this.styles = r`#default{display:flex;padding:var(--gmp-padding-container,16px 24px)}#default .main{flex:1}#default slot[name=suffix]{align-items:center;display:flex;margin:var(--gmp-margin-suffix,0 0 0 16px)}#default .title{color:var(--gmp-color-title,#202124);line-height:var(--gmp-line-height-title,20px);font-size:var(--gmp-font-size-title,1rem);font-weight:var(--gmp-font-weight-title,500)}#default .caption{color:var(--gmp-color-caption,#70757a);line-height:var(--gmp-line-height-caption,20px);font-size:var(--gmp-font-size-caption,14px);font-weight:var(--gmp-font-weight-caption,400)}` } async updated(t) { (t.has("placeId") || t.has("fields")) && (await this.loadConfig(), this.fetchMissingFields()) } getTemplateContext() { return this.place } renderDefault() { return O`<div id="default"><div class="main">${this.place && this.renderDefaultPlaceItem(this.place)}</div><slot name="suffix"></slot></div>` } renderDefaultPlaceItem(t) { const e = this.placesController.getTypeLabel(t), i = this.placesController.getPriceLevelLabel(t), s = this.placesController.getSimplifiedAddress(t); return O`${t.name && O`<div class="title">${t.name}</div>`}<div class="caption">${t.rating && O`${t.rating}<gmp-star-rating .value="${t.rating}"></gmp-star-rating>${t.user_ratings_total && O`(${t.user_ratings_total})`} ${i && "Â· " + i}<br>`} ${e} ${e && s && "Â·"} ${s}<br>${t.formatted_phone_number}</div>` } async fetchMissingFields() { this.placeId ? this.place = await this.placesController.getDetailsByPlaceAndFields({ ...this.data, place_id: this.placeId }, this.fields) : console.warn("A Place ID must be supplied to the <gmp-place-item> element.") } }; fi([tt({ type: String, attribute: "place-id" })], mi.prototype, "placeId", void 0), fi([tt({ type: Object })], mi.prototype, "data", void 0), fi([et()], mi.prototype, "place", void 0), fi([tt({ converter: { fromAttribute: t => t.split(/\s+/).filter((t => "" !== t)), toAttribute: t => t.join(" ") } })], mi.prototype, "fields", void 0), mi = fi([X("gmp-place-item")], mi); var gi = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let yi = class extends ht { constructor() { super(...arguments), this.places = [] } static { this.styles = r`ul{list-style-type:none;margin:0;padding:0}li{border-bottom:1px solid #e8eaed;cursor:pointer;padding:.8em;position:relative}li.selected,li:hover{background-color:rgba(60,64,67,.04)}li .title{color:#202124;font-size:1rem;font-weight:500}li .subtitle{color:#70757a;font-size:.875rem;font-weight:400;margin-top:6px}.truncated{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}` } handleListItemClick(t, e) { const i = new CustomEvent("clicklistitem", { detail: { place: t, index: e } }); this.dispatchEvent(i) } render() { return O`<ul>${Ot(this.places, ((t, e) => O`<li class="${Et({ selected: e === this.selectedIndex })}" @click="${() => this.handleListItemClick(t, e)}"><div class="title truncated">${t.name}</div><div class="subtitle truncated">${t.formatted_address}</div></li>`))}</ul>` } }; gi([tt({ type: Array })], yi.prototype, "places", void 0), gi([tt({ type: Number })], yi.prototype, "selectedIndex", void 0), yi = gi([X("gmp-place-list")], yi); class vi { constructor(t) { (this.host = t).addController(this) } geocode(t) { return new Promise(((e, i) => { this.getGeocoder().geocode(t, ((t, s) => { s === google.maps.GeocoderStatus.OK ? e(t) : s === google.maps.GeocoderStatus.ZERO_RESULTS ? e([]) : i(s) })) })) } async geocodeToPlaceResults(t) { return (await this.geocode(t)).map((t => ({ place_id: t.place_id, name: t.formatted_address, types: t.types, formatted_address: t.formatted_address, address_components: t.address_components, geometry: t.geometry }))) } getGeocoder() { return this.geocoder || (this.geocoder = new google.maps.Geocoder), this.geocoder } hostUpdate() { } } var bi = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let ki = class extends ht { constructor() { super(), this.map = null, this.autocompleteOptions = {}, this.placeholder = "", this.geocodingController = new vi(this), this.autocomplete = this.initializeAutocomplete() } static { this.styles = r`:host{display:block}#default{position:relative}#default input{border:1px solid #dadce0;border-radius:8px;box-sizing:border-box;font-size:16px;height:24px;padding:16px;padding-right:84px;width:100%}#default .overlay{display:flex;position:absolute;right:5px;top:0}#default .divider{border-right:1px solid #dadce0;margin:5px}#default img{display:block}#default button{background:0 0;border:none;padding:5px}#default button:enabled{cursor:pointer}#default button.muted img,#default button:disabled img{filter:invert(84%) sepia(0) saturate(63%) hue-rotate(171deg) brightness(86%) contrast(89%)}#default #search-btn:focus,#default #search-btn:not(.muted),#default button:enabled img:hover{filter:invert(61%) sepia(66%) saturate(6227%) hue-rotate(204deg) brightness(104%) contrast(91%)}` } initializeAutocomplete() { return new Promise((async t => { await this.loadConfig(); const e = new ((await bt.getGoogleMaps(this.tagName)).places.Autocomplete)(this.inputEl, this.autocompleteOptions); e.addListener("place_changed", (async () => { const t = e.getPlace(); t?.geometry && (this.searchBtnEl.disabled = !0, this.dispatchEvent(new CustomEvent("placechanged", { detail: t }))) })), t(e) })) } async updated(t) { t.has("map") && this.map && (await this.autocomplete)?.bindTo("bounds", this.map) } handleInput(t) { this.clearBtnEl.disabled = !t.target.value, this.searchBtnEl.disabled = !t.target.value, this.searchBtnEl.classList.remove("muted") } handleBlur() { this.searchBtnEl.classList.add("muted") } async handleKeyUp(t) { "Enter" === t.key && await this.geocode() } handleClear() { this.inputEl.value = "", this.clearBtnEl.disabled = !0, this.searchBtnEl.disabled = !0, this.dispatchEvent(new CustomEvent("placechanged", { detail: void 0 })) } async geocode() { const t = this.inputEl.value; if (!t) return; const e = { address: t }; this.map && (e.bounds = this.map.getBounds() ?? void 0); const i = (await this.geocodingController.geocodeToPlaceResults(e)).filter((t => t.formatted_address && t.geometry?.location)); i.length > 0 && (this.inputEl.value = i[0].formatted_address, this.searchBtnEl.disabled = !0, this.dispatchEvent(new CustomEvent("placechanged", { detail: i[0] }))) } render() { return O`<div id="default"><input placeholder="${this.placeholder}" @blur="${this.handleBlur}" @input="${this.handleInput}" @keyup="${this.handleKeyUp}"><div class="overlay"><button id="search-btn" class="muted" @click="${this.geocode}" disabled="disabled"><img src="https://fonts.gstatic.com/s/i/googlematerialicons/search/v16/24px.svg" alt="search"></button><div class="divider"></div><button id="clear-btn" @click="${this.handleClear}" disabled="disabled"><img src="https://fonts.gstatic.com/s/i/googlematerialicons/close/v16/24px.svg" alt="search"></button></div><div></div></div>` } }; bi([tt({ attribute: !1 })], ki.prototype, "autocomplete", void 0), bi([tt({ attribute: !1 })], ki.prototype, "map", void 0), bi([tt({ type: Object })], ki.prototype, "autocompleteOptions", void 0), bi([tt({ type: String })], ki.prototype, "placeholder", void 0), bi([st("input")], ki.prototype, "inputEl", void 0), bi([st("#search-btn")], ki.prototype, "searchBtnEl", void 0), bi([st("#clear-btn")], ki.prototype, "clearBtnEl", void 0), ki = bi([X("gmp-place-search")], ki); var _i = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let Si = class extends ht { constructor() { super(...arguments), this.minHeight = 300, this.horizontal = !1 } static { this.styles = r`#ul.horizontal{white-space:nowrap}#ul:not(.horizontal) ::slotted([slot=li]){border-top:var(--gmp-list-border,1px solid #e8eaed);display:block}#ul.horizontal ::slotted([slot=li]){border-left:var(--gmp-list-border,1px solid #e8eaed);display:inline-block}` } connectedCallback() { super.connectedCallback(), this.parentElement && (this.resizeObserver = new ResizeObserver((() => { this.parentElement?.clientHeight && (this.horizontal = this.parentElement.clientHeight < this.minHeight) })), this.resizeObserver.observe(this.parentElement)) } disconnectedCallback() { this.resizeObserver?.disconnect(), super.disconnectedCallback() } render() { return O`<div id="ul" class="${Et({ horizontal: this.horizontal })}"><slot name="li"></slot></div>` } }; _i([tt({ type: Number, attribute: "min-height" })], Si.prototype, "minHeight", void 0), _i([et()], Si.prototype, "horizontal", void 0), _i([tt({ type: Number })], Si.prototype, "selectedIndex", void 0), Si = _i([X("gmp-responsive-list")], Si); var Pi = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; let wi = class extends ht { static { this.styles = r`:host{display:flex;height:100%;width:100%}slot[name=sidebar]::slotted(*){box-sizing:border-box;height:100%;overflow-y:auto;width:400px}#map-container{flex:1}slot[name=map]::slotted(gmp-map){height:100%}@media only screen and (max-width:600px){:host{flex-direction:column-reverse}slot[name=sidebar]::slotted(*){width:100%}}` } init() { } render() { return O`<div id="sidebar-container"><slot name="sidebar"></slot></div><div id="map-container"><slot name="map"></slot></div>` } }; wi = Pi([X("gmp-sidebar-layout")], wi); var xi = function (t, e, i, s) { var r, o = arguments.length, n = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(t, e, i, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(e, i, n) : r(e, i)) || n); return o > 3 && n && Object.defineProperty(e, i, n), n }; var $i; !function (t) { t.FULL = "full", t.HALF = "half", t.EMPTY = "empty" }($i || ($i = {})); let Ci = class extends ht { static { this.styles = r`.star-icon{font-size:var(--gmp-font-size-caption,14px);position:relative}.star-icon.full{color:var(--gmp-color-rating-full,#fabc02)}.star-icon.empty,.star-icon.half{color:var(--gmp-color-rating-empty,#dadce0)}.star-icon.half:before{color:var(--gmp-color-rating-full,#fabc02);content:'\\2605';overflow:hidden;position:absolute;width:50%}` } render() { return Ot(this.getStarIcons(), (t => O`<span class="star-icon ${t}">â˜…</span>`)) } getStarIcons() { const t = (this.value ?? 0) / 5; let e = Math.round(5 * t * 2); const i = []; for (; e > 1;)i.push($i.FULL), e -= 2; for (e > 0 && i.push($i.HALF); i.length < 5;)i.push($i.EMPTY); return i } }; xi([tt({ type: Number })], Ci.prototype, "value", void 0), Ci = xi([X("gmp-star-rating")], Ci); export { bt as GmpApiLoader, ut as GmpConfigurator, _t as GmpDirectionsButton, Pt as GmpDummyComponent, Mt as GmpLocatorSolution, jt as GmpMap, zt as GmpMapDirections, Zt as GmpMapMarker, Ft as GmpMapMarkerGroup, mi as GmpPlaceItem, yi as GmpPlaceList, ki as GmpPlaceSearch, Si as GmpResponsiveList, wi as GmpSidebarLayout, Ci as GmpStarRating };
